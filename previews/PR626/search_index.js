var documenterSearchIndex = {"docs":
[{"location":"nonstiff/high_weak_order/#High-Weak-Order-Methods","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"These methods are specifically designed for problems where weak convergence is more important than strong convergence. They are optimal for Monte Carlo simulations, computing expectations, moments, and other statistical properties of solutions.","category":"page"},{"location":"nonstiff/high_weak_order/#Recommended-High-Weak-Order-Methods","page":"High Weak Order Methods","title":"Recommended High Weak Order Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#DRI1-Debrabant-Rößler-Method-(Weak-Order-2)","page":"High Weak Order Methods","title":"DRI1 - Debrabant-Rößler Method (Weak Order 2)","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.DRI1","page":"High Weak Order Methods","title":"StochasticDiffEq.DRI1","text":"Debrabant, K. and Rößler A., Families of efficient second order Runge–Kutta methods for the weak approximation of Itô stochastic differential equations, Applied Numerical Mathematics 59, pp. 582–594 (2009) DOI:10.1016/j.apnum.2008.03.012\n\nDRI1()\n\nDRI1: Debrabant-Rößler Implicit Method (High Weak Order)\n\nAdaptive high-order method optimized for weak convergence with minimized error constants. Excellent for Monte Carlo simulations and moment calculations.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0 (optimized with minimized error constants)\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive noise)\nSDE interpretation: Itô\n\nWhen to Use\n\nOptimal for weak convergence requirements\nMonte Carlo simulations where statistical properties matter most\nComputing expectations, moments, and probability distributions\nWhen weak accuracy is more important than pathwise accuracy\nFor problems requiring diverse noise types\n\nWeak vs Strong Convergence\n\nWeak convergence: Convergence of expectations E[f(X_T)]\nStrong convergence: Pathwise convergence |XT - XT^h|\nDRI1 prioritizes weak convergence with optimized error constants\n\nAlgorithm Features\n\nMinimized error constants for better practical performance\nHandles complex noise structures including non-commuting terms\nAdaptive time stepping for efficiency\n\nReferences\n\nDebrabant, K. and Rößler A., \"Families of efficient second order Runge–Kutta methods for the weak approximation of Itô stochastic differential equations\", Applied Numerical Mathematics 59, pp. 582–594 (2009)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#DRI1NM-Debrabant-Rößler-for-Non-mixing-Diagonal-Problems","page":"High Weak Order Methods","title":"DRI1NM - Debrabant-Rößler for Non-mixing Diagonal Problems","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.DRI1NM","page":"High Weak Order Methods","title":"StochasticDiffEq.DRI1NM","text":"Debrabant, K. and Rößler A., Families of efficient second order Runge–Kutta methods for the weak approximation of Itô stochastic differential equations, Applied Numerical Mathematics 59, pp. 582–594 (2009) DOI:10.1016/j.apnum.2008.03.012\n\nDRI1NM()\n\nDRI1NM: Debrabant-Rößler Implicit Non-Mixing Method (High Weak Order)\n\nSpecialized version of DRI1 for non-mixing diagonal and scalar additive noise problems.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0 (optimized with minimized error constants)\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: Non-mixing diagonal and scalar additive noise\nSDE interpretation: Itô\n\nWhen to Use\n\nNon-mixing diagonal problems: du[k] = f(u[k]) dt + σ[k] dW[k]\nScalar additive noise problems\nWhen DRI1 is too general/expensive for the problem structure\nMonte Carlo simulations with special structure\n\nNon-Mixing Diagonal Structure\n\nOptimized for problems where:\n\ndu[1] = f₁(u[1])dt + σ₁ dW[1]\ndu[2] = f₂(u[2])dt + σ₂ dW[2]\n...\n\nEach component depends only on itself (no coupling).\n\nAlgorithm Advantages\n\nMore efficient than general DRI1 for structured problems\nExploits special structure for better performance\nMaintains weak order 2.0 with minimized constants\n\nReferences\n\nDebrabant, K. and Rößler A., \"Families of efficient second order Runge–Kutta methods for the weak approximation of Itô stochastic differential equations\", Applied Numerical Mathematics 59, pp. 582–594 (2009)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#Other-Weak-Order-2-Methods","page":"High Weak Order Methods","title":"Other Weak Order 2 Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#RI1,-RI3,-RI5,-RI6-Rößler-Methods","page":"High Weak Order Methods","title":"RI1, RI3, RI5, RI6 - Rößler Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RI1","page":"High Weak Order Methods","title":"StochasticDiffEq.RI1","text":"Rößler A., Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations, SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009) DOI:10.1137/060673308\n\nRI1()\n\nRI1: Rößler Implicit Method 1 (High Weak Order)\n\nAdaptive weak order 2.0 method for Itô SDEs with deterministic order 3.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nGeneral weak convergence problems\nMonte Carlo simulations with various noise structures\nWhen weak order 2.0 is sufficient\nAlternative to DRI1 with different characteristics\n\nReferences\n\nRößler A., \"Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations\", SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RI3","page":"High Weak Order Methods","title":"StochasticDiffEq.RI3","text":"Rößler A., Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations, SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009) DOI:10.1137/060673308\n\nRI3()\n\nRI3: Rößler Implicit Method 3 (High Weak Order)\n\nAlternative adaptive weak order 2.0 method with different stability characteristics.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nAlternative to RI1 with different characteristics\nWhen RI1 performance is unsatisfactory\nBenchmarking different weak order 2.0 methods\n\nReferences\n\nRößler A., \"Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations\", SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RI5","page":"High Weak Order Methods","title":"StochasticDiffEq.RI5","text":"Rößler A., Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations, SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009) DOI:10.1137/060673308\n\nRI5()\n\nRI5: Rößler Implicit Method 5 (High Weak Order)\n\nAnother variant in the RI family of weak order 2.0 methods.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nPart of RI family comparison studies\nWhen other RI methods don't provide desired characteristics\nResearch applications requiring different RI variants\n\nReferences\n\nRößler A., \"Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations\", SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RI6","page":"High Weak Order Methods","title":"StochasticDiffEq.RI6","text":"Rößler A., Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations, SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009) DOI:10.1137/060673308\n\nRI6()\n\nRI6: Rößler Implicit Method 6 (High Weak Order)\n\nFinal method in the RI family with deterministic order 2 (lower than other RI methods).\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nWhen lower deterministic order is acceptable\nPotentially more efficient than RI1/RI3/RI5\nCompleting RI family comparisons\n\nAlgorithm Features\n\nLower deterministic order may reduce computational cost\nStill maintains weak order 2.0 for stochastic problems\nFinal variant in the comprehensive RI family\n\nReferences\n\nRößler A., \"Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations\", SIAM J. Numer. Anal., 47, pp. 1713-1738 (2009)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#RDI-Methods-Alternative-Weak-Order-2","page":"High Weak Order Methods","title":"RDI Methods - Alternative Weak Order 2","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RDI2WM","page":"High Weak Order Methods","title":"StochasticDiffEq.RDI2WM","text":"Debrabant, K. and Rößler A., Classification of Stochastic Runge–Kutta Methods for the Weak Approximation of Stochastic Differential Equations, Mathematics and Computers in Simulation 77, pp. 408-420 (2008) DOI:10.1016/j.matcom.2007.04.016\n\nRDI2WM()\n\nRDI2WM: Runge-Kutta Debrabant Implicit 2 Weak Method (High Weak Order)\n\nAdaptive weak order 2.0 method for Itô SDEs with deterministic order 2.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nWeak order 2.0 problems with adaptive stepping\nAlternative to DRI1 and RI methods\nWhen deterministic order 2.0 is sufficient\nMonte Carlo simulations requiring adaptive control\n\nReferences\n\nDebrabant, K. and Rößler A., \"Classification of Stochastic Runge–Kutta Methods for the Weak Approximation of Stochastic Differential Equations\", Mathematics and Computers in Simulation 77, pp. 408-420 (2008)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RDI3WM","page":"High Weak Order Methods","title":"StochasticDiffEq.RDI3WM","text":"Debrabant, K. and Rößler A., Classification of Stochastic Runge–Kutta Methods for the Weak Approximation of Stochastic Differential Equations, Mathematics and Computers in Simulation 77, pp. 408-420 (2008) DOI:10.1016/j.matcom.2007.04.016\n\nRDI3WM()\n\nRDI3WM: Runge-Kutta Debrabant Implicit 3 Weak Method (High Weak Order)\n\nAdaptive weak order 2.0 method with higher deterministic order 3.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nWhen both weak order 2.0 and deterministic order 3.0 are needed\nProblems with significant deterministic components\nAlternative to DRI1 with different characteristics\nHigh accuracy requirements for both stochastic and deterministic parts\n\nReferences\n\nDebrabant, K. and Rößler A., \"Classification of Stochastic Runge–Kutta Methods for the Weak Approximation of Stochastic Differential Equations\", Mathematics and Computers in Simulation 77, pp. 408-420 (2008)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RDI4WM","page":"High Weak Order Methods","title":"StochasticDiffEq.RDI4WM","text":"Debrabant, K. and Rößler A., Classification of Stochastic Runge–Kutta Methods for the Weak Approximation of Stochastic Differential Equations, Mathematics and Computers in Simulation 77, pp. 408-420 (2008) DOI:10.1016/j.matcom.2007.04.016\n\nRDI4WM()\n\nRDI4WM: Runge-Kutta Debrabant Implicit 4 Weak Method (High Weak Order)\n\nFourth variant in the RDI family with weak order 2.0 and deterministic order 3.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nFinal alternative in the RDI family\nWhen other RDI methods don't provide desired performance\nCompleting comprehensive RDI method comparisons\nResearch applications requiring all RDI variants\n\nReferences\n\nDebrabant, K. and Rößler A., \"Classification of Stochastic Runge–Kutta Methods for the Weak Approximation of Stochastic Differential Equations\", Mathematics and Computers in Simulation 77, pp. 408-420 (2008)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#W2Ito1-Efficient-Weak-Order-2","page":"High Weak Order Methods","title":"W2Ito1 - Efficient Weak Order 2","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.W2Ito1","page":"High Weak Order Methods","title":"StochasticDiffEq.W2Ito1","text":"Tang, X., & Xiao, A., Efficient weak second-order stochastic Runge–Kutta methods for Itô stochastic differential equations, BIT Numerical Mathematics, 57, 241-260 (2017) DOI: 10.1007/s10543-016-0618-9\n\nW2Ito1()\n\nW2Ito1: Wang-Tang-Xiao Weak Order 2 Method (High Weak Order)\n\nEfficient weak second-order method for Itô SDEs with adaptive stepping.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Adaptive\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nModern efficient weak order 2.0 method\nWhen computational efficiency is important for weak convergence\nAlternative to older weak order 2.0 methods\nMonte Carlo simulations requiring good performance\n\nAlgorithm Features\n\nDesigned for computational efficiency\nGood balance of accuracy and cost for weak problems\nMore recent development than classical methods\n\nReferences\n\nTang, X., & Xiao, A., \"Efficient weak second-order stochastic Runge–Kutta methods for Itô stochastic differential equations\", BIT Numerical Mathematics, 57, 241-260 (2017)# Stratonovich sense\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#Fixed-Step-Methods","page":"High Weak Order Methods","title":"Fixed Step Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#PL1WM,-PL1WMA-Platen-Methods","page":"High Weak Order Methods","title":"PL1WM, PL1WMA - Platen Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.PL1WM","page":"High Weak Order Methods","title":"StochasticDiffEq.PL1WM","text":"Kloeden, P.E., Platen, E., Numerical Solution of Stochastic Differential Equations. Springer. Berlin Heidelberg (2011)\n\nPL1WM()\n\nPL1WM: Platen Weak Method 1 (High Weak Order)\n\nFixed step weak order 2.0 method from the classical Kloeden-Platen textbook.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Itô\n\nWhen to Use\n\nClassical reference implementation for weak order 2.0\nFixed step applications with predetermined step size\nEducational purposes and textbook examples\nBaseline comparison for more advanced methods\n\nAlgorithm Features\n\nWell-established classical method\nSimple implementation\nStandard reference from foundational SDE literature\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer. Berlin Heidelberg (2011)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.PL1WMA","page":"High Weak Order Methods","title":"StochasticDiffEq.PL1WMA","text":"Kloeden, P.E., Platen, E., Numerical Solution of Stochastic Differential Equations. Springer. Berlin Heidelberg (2011)\n\nPL1WMA()\n\nPL1WMA: Platen Weak Method 1 Additive (High Weak Order)\n\nSpecialized version of PL1WM optimized for additive noise problems.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: Additive noise only\nSDE interpretation: Itô\n\nWhen to Use\n\nAdditive noise problems with fixed step size\nWhen PL1WM is too general for additive structure\nClassical reference for additive noise weak methods\nEducational and benchmarking purposes\n\nAdditive Noise Structure\n\nSpecialized for SDEs of the form:\n\ndu = f(u,t)dt + σ(t) dW\n\nwhere diffusion σ doesn't depend on solution u.\n\nAlgorithm Features\n\nMore efficient than PL1WM for additive problems\nClassical foundation method\nSimplified implementation for additive case\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer. Berlin Heidelberg (2011)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#Stratonovich-Methods","page":"High Weak Order Methods","title":"Stratonovich Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#RS1,-RS2-Rößler-Stratonovich-Methods","page":"High Weak Order Methods","title":"RS1, RS2 - Rößler Stratonovich Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RS1","page":"High Weak Order Methods","title":"StochasticDiffEq.RS1","text":"Rößler A., Second order Runge–Kutta methods for Stratonovich stochastic differential equations, BIT Numerical Mathematics 47, pp. 657-680 (2007) DOI:10.1007/s10543-007-0130-3\n\nRS1()\n\nRS1: Rößler Stratonovich Method 1 (High Weak Order)\n\nFixed step weak order 2.0 method specifically designed for Stratonovich SDEs.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Stratonovich\n\nWhen to Use\n\nStratonovich SDEs requiring weak order 2.0\nFixed step applications with predetermined step size\nProblems naturally formulated in Stratonovich interpretation\nWhen physical interpretation requires Stratonovich calculus\n\nStratonovich Interpretation\n\nOptimized for SDEs in Stratonovich form:\n\ndu = f(u,t)dt + g(u,t)∘dW\n\nwhere ∘ denotes Stratonovich integration.\n\nReferences\n\nRößler A., \"Second order Runge–Kutta methods for Stratonovich stochastic differential equations\", BIT Numerical Mathematics 47, pp. 657-680 (2007)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.RS2","page":"High Weak Order Methods","title":"StochasticDiffEq.RS2","text":"Rößler A., Second order Runge–Kutta methods for Stratonovich stochastic differential equations, BIT Numerical Mathematics 47, pp. 657-680 (2007) DOI:10.1007/s10543-007-0130-3\n\nRS2()\n\nRS2: Rößler Stratonovich Method 2 (High Weak Order)\n\nAlternative fixed step weak order 2.0 method for Stratonovich SDEs with higher deterministic order.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 3.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: All forms (diagonal, non-diagonal, non-commuting, scalar additive)\nSDE interpretation: Stratonovich\n\nWhen to Use\n\nStratonovich SDEs with significant deterministic components\nWhen higher deterministic accuracy than RS1 is needed\nFixed step applications requiring better deterministic performance\nBenchmarking against RS1\n\nAlgorithm Features\n\nHigher deterministic order than RS1\nMay be more expensive per step than RS1\nBetter for problems with large deterministic components\n\nReferences\n\nRößler A., \"Second order Runge–Kutta methods for Stratonovich stochastic differential equations\", BIT Numerical Mathematics 47, pp. 657-680 (2007)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#NON,-NON2-Non-commutative-Stratonovich","page":"High Weak Order Methods","title":"NON, NON2 - Non-commutative Stratonovich","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.NON","page":"High Weak Order Methods","title":"StochasticDiffEq.NON","text":"Komori, Y., Weak second-order stochastic Runge–Kutta methods for non-commutative stochastic differential equations, Journal of Computational and Applied Mathematics 206, pp. 158 – 173 (2007) DOI:10.1016/j.cam.2006.06.006\n\nNON: High Weak Order Method Fixed step weak order 2.0 for Stratonovich SDEs (deterministic order 4). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.NON2","page":"High Weak Order Methods","title":"StochasticDiffEq.NON2","text":"NON2()\n\nNON2: Enhanced Non-commutative Stratonovich Method (High Weak Order)\n\nImproved version of the NON method with enhanced efficiency for non-commutative Stratonovich SDEs.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nTime stepping: Fixed step size\nNoise types: Non-commutative noise\nSDE interpretation: Stratonovich\n\nWhen to Use\n\nEnhanced version of NON with better efficiency\nNon-commutative Stratonovich SDEs requiring improved performance\nWhen NON is too expensive or inefficient\nModern alternative to classical NON method\n\nAlgorithm Features\n\nMore efficient than original NON method\nMaintains weak order 2.0 convergence\nEnhanced computational techniques\n\nReferences\n\nKomori, Y., & Burrage, K., \"Supplement: Efficient weak second order stochastic Runge–Kutta methods for non-commutative Stratonovich stochastic differential equations\", Journal of computational and applied mathematics, 235(17), pp. 5326-5329 (2011)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#COM-Commutative-Stratonovich","page":"High Weak Order Methods","title":"COM - Commutative Stratonovich","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.COM","page":"High Weak Order Methods","title":"StochasticDiffEq.COM","text":"COM()\n\nCOM: Commutative Stratonovich Method (High Weak Order)\n\nFixed step method optimized for commutative Stratonovich SDEs.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: Depends on implementation\nTime stepping: Fixed step size\nNoise types: Commutative noise only\nSDE interpretation: Stratonovich\n\nWhen to Use\n\nCommutative Stratonovich SDEs\nWhen noise terms satisfy commutativity conditions\nMore efficient alternative to NON for commutative cases\nFixed step applications with commutative structure\n\nCommutative Noise\n\nOptimized for Stratonovich SDEs where:\n\n[g_i, g_j] = g_i(∂g_j/∂x) - g_j(∂g_i/∂x) = 0\n\nfor all noise terms.\n\nAlgorithm Features\n\nMore efficient than NON for commutative cases\nExploits commutativity for computational savings\nSpecialized for Stratonovich interpretation\n\nReferences\n\nKomori, Y., \"Weak order stochastic Runge–Kutta methods for commutative stochastic differential equations\", Journal of Computational and Applied Mathematics 203, pp. 57 – 79 (2007)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#Specialized-Methods","page":"High Weak Order Methods","title":"Specialized Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#SIEA,-SMEA,-SIEB,-SMEB-Tocino-Vigo-Aguiar-Methods","page":"High Weak Order Methods","title":"SIEA, SMEA, SIEB, SMEB - Tocino-Vigo-Aguiar Methods","text":"","category":"section"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.SIEA","page":"High Weak Order Methods","title":"StochasticDiffEq.SIEA","text":"Tocino, A. and Vigo-Aguiar, J., Weak Second Order Conditions for Stochastic Runge- Kutta Methods, SIAM Journal on Scientific Computing 24, pp. 507 - 523 (2002) DOI:10.1137/S1064827501387814\n\nSIEA()\n\nSIEA: Stochastic Improved Euler A Method (High Weak Order)\n\nStochastic generalization of the improved Euler method for Itô SDEs.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: Diagonal and scalar additive noise\nSDE interpretation: Itô\n\nWhen to Use\n\nFixed step applications with diagonal/scalar additive noise\nWhen stochastic version of improved Euler is desired\nEducational purposes (connection to classical methods)\nBaseline for Tocino-Vigo-Aguiar method comparisons\n\nAlgorithm Features\n\nBased on classical improved Euler method\nSpecialized for additive noise structures\nSimple and well-understood foundation\n\nReferences\n\nTocino, A. and Vigo-Aguiar, J., \"Weak Second Order Conditions for Stochastic Runge-Kutta Methods\", SIAM Journal on Scientific Computing 24, pp. 507-523 (2002)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.SMEA","page":"High Weak Order Methods","title":"StochasticDiffEq.SMEA","text":"Tocino, A. and Vigo-Aguiar, J., Weak Second Order Conditions for Stochastic Runge- Kutta Methods, SIAM Journal on Scientific Computing 24, pp. 507 - 523 (2002) DOI:10.1137/S1064827501387814\n\nSMEA()\n\nSMEA: Stochastic Modified Euler A Method (High Weak Order)\n\nStochastic generalization of the modified Euler method for Itô SDEs.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: Diagonal and scalar additive noise\nSDE interpretation: Itô\n\nWhen to Use\n\nFixed step applications with diagonal/scalar additive noise\nWhen stochastic version of modified Euler is desired\nAlternative to SIEA with different characteristics\nEducational and comparison purposes\n\nAlgorithm Features\n\nBased on classical modified Euler method\nDifferent approach than SIEA for same problem class\nSpecialized for additive noise structures\n\nReferences\n\nTocino, A. and Vigo-Aguiar, J., \"Weak Second Order Conditions for Stochastic Runge-Kutta Methods\", SIAM Journal on Scientific Computing 24, pp. 507-523 (2002)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.SIEB","page":"High Weak Order Methods","title":"StochasticDiffEq.SIEB","text":"Tocino, A. and Vigo-Aguiar, J., Weak Second Order Conditions for Stochastic Runge- Kutta Methods, SIAM Journal on Scientific Computing 24, pp. 507 - 523 (2002) DOI:10.1137/S1064827501387814\n\nSIEB()\n\nSIEB: Stochastic Improved Euler B Method (High Weak Order)\n\nAlternative stochastic generalization of the improved Euler method.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: Diagonal and scalar additive noise\nSDE interpretation: Itô\n\nWhen to Use\n\nAlternative to SIEA with different coefficients\nFixed step applications requiring different stability properties\nComparing different improved Euler generalizations\nWhen SIEA performance is unsatisfactory\n\nAlgorithm Features\n\nVariant B of stochastic improved Euler approach\nDifferent coefficients than SIEA\nMay have different stability or accuracy characteristics\n\nReferences\n\nTocino, A. and Vigo-Aguiar, J., \"Weak Second Order Conditions for Stochastic Runge-Kutta Methods\", SIAM Journal on Scientific Computing 24, pp. 507-523 (2002)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#StochasticDiffEq.SMEB","page":"High Weak Order Methods","title":"StochasticDiffEq.SMEB","text":"Tocino, A. and Vigo-Aguiar, J., Weak Second Order Conditions for Stochastic Runge- Kutta Methods, SIAM Journal on Scientific Computing 24, pp. 507 - 523 (2002) DOI:10.1137/S1064827501387814\n\nSMEB()\n\nSMEB: Stochastic Modified Euler B Method (High Weak Order)\n\nAlternative stochastic generalization of the modified Euler method.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 2.0\nDeterministic Order: 2.0 (when noise = 0)\nTime stepping: Fixed step size\nNoise types: Diagonal and scalar additive noise\nSDE interpretation: Itô\n\nWhen to Use\n\nAlternative to SMEA with different coefficients\nFixed step applications requiring different characteristics\nCompleting Tocino-Vigo-Aguiar method family comparisons\nWhen SMEA performance is unsatisfactory\n\nAlgorithm Features\n\nVariant B of stochastic modified Euler approach\nDifferent coefficients than SMEA\nCompletes the family of Tocino-Vigo-Aguiar methods\n\nReferences\n\nTocino, A. and Vigo-Aguiar, J., \"Weak Second Order Conditions for Stochastic Runge-Kutta Methods\", SIAM Journal on Scientific Computing 24, pp. 507-523 (2002)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/high_weak_order/#Weak-vs-Strong-Convergence","page":"High Weak Order Methods","title":"Weak vs Strong Convergence","text":"","category":"section"},{"location":"nonstiff/high_weak_order/","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"Strong Convergence: Measures pathwise error E[|X(T) - Xh(T)|^p] Weak Convergence: Measures error in expectations E[f(X(T))] - E[f(Xh(T))]","category":"page"},{"location":"nonstiff/high_weak_order/#When-to-Use-Weak-Order-Methods:","page":"High Weak Order Methods","title":"When to Use Weak Order Methods:","text":"","category":"section"},{"location":"nonstiff/high_weak_order/","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"Monte Carlo simulations\nComputing expectations and moments\nStatistical analysis of SDEs\nWhen pathwise accuracy is not critical\nLarge ensemble simulations","category":"page"},{"location":"nonstiff/high_weak_order/#Advantages:","page":"High Weak Order Methods","title":"Advantages:","text":"","category":"section"},{"location":"nonstiff/high_weak_order/","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"Often more efficient for statistical quantities\nCan use larger time steps while maintaining weak accuracy\nOptimized error constants for better practical performance","category":"page"},{"location":"nonstiff/high_weak_order/#Method-Selection-Guide","page":"High Weak Order Methods","title":"Method Selection Guide","text":"","category":"section"},{"location":"nonstiff/high_weak_order/","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"General purpose weak order 2: DRI1\nNon-mixing diagonal: DRI1NM\nFixed step: PL1WM, RS1/RS2\nStratonovich: RS1, RS2, NON, NON2\nSpecialized applications: RI methods, RDI methods","category":"page"},{"location":"nonstiff/high_weak_order/#References","page":"High Weak Order Methods","title":"References","text":"","category":"section"},{"location":"nonstiff/high_weak_order/","page":"High Weak Order Methods","title":"High Weak Order Methods","text":"Debrabant, K. and Rößler A., \"Families of efficient second order Runge–Kutta methods for the weak approximation of Itô stochastic differential equations\"\nRößler A., \"Second Order Runge–Kutta Methods for Itô Stochastic Differential Equations\"","category":"page"},{"location":"stiff/split_step_methods/#Split-Step-Methods-for-Fully-Stiff-Problems","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"When both drift and diffusion terms are stiff, split-step methods treat both parts implicitly. These methods can handle the most challenging stiff SDE problems.","category":"page"},{"location":"stiff/split_step_methods/#Split-Step-Implicit-Methods","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Implicit Methods","text":"","category":"section"},{"location":"stiff/split_step_methods/#ISSEM-Implicit-Split-Step-Euler-Maruyama","page":"Split-Step Methods for Fully Stiff Problems","title":"ISSEM - Implicit Split-Step Euler-Maruyama","text":"","category":"section"},{"location":"stiff/split_step_methods/#ISSEulerHeun-Implicit-Split-Step-Euler-Heun","page":"Split-Step Methods for Fully Stiff Problems","title":"ISSEulerHeun - Implicit Split-Step Euler-Heun","text":"","category":"section"},{"location":"stiff/split_step_methods/#When-to-Use-Split-Step-Methods","page":"Split-Step Methods for Fully Stiff Problems","title":"When to Use Split-Step Methods","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Use ISSEM when:","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Both drift and diffusion are stiff\nExplicit methods fail even with small time steps\nStandard implicit methods (ImplicitEM) are insufficient\nWorking with Itô interpretation","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Use ISSEulerHeun when:","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Both drift and diffusion are stiff\nWorking with Stratonovich interpretation\nNeed implicit treatment of diffusion term","category":"page"},{"location":"stiff/split_step_methods/#Understanding-Full-Stiffness","page":"Split-Step Methods for Fully Stiff Problems","title":"Understanding Full Stiffness","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Drift Stiffness: Large negative eigenvalues in f(u,t) Diffusion Stiffness: Large coefficients in g(u,t) causing instability","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Detection Signs:","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"ImplicitEM still requires very small time steps\nSolutions become unstable despite implicit drift treatment\nLarge diffusion coefficients cause numerical artifacts","category":"page"},{"location":"stiff/split_step_methods/#Algorithm-Structure","page":"Split-Step Methods for Fully Stiff Problems","title":"Algorithm Structure","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Split-step methods solve:","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"du = f(u,t)dt + g(u,t)dW","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"By treating both terms implicitly through operator splitting or fully implicit schemes.","category":"page"},{"location":"stiff/split_step_methods/#Performance-Considerations","page":"Split-Step Methods for Fully Stiff Problems","title":"Performance Considerations","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"More expensive per step than drift-only implicit methods\nMay require smaller time steps than expected\nJacobian computations for both drift and diffusion\nNonlinear solve complexity increases","category":"page"},{"location":"stiff/split_step_methods/#Configuration","page":"Split-Step Methods for Fully Stiff Problems","title":"Configuration","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Same options as other implicit methods:","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"ISSEM(\n    linsolve = KrylovJL_GMRES(),\n    nlsolve = NLNewton(),\n    theta = 1.0,\n    autodiff = true\n)","category":"page"},{"location":"stiff/split_step_methods/#Alternative-Approaches","page":"Split-Step Methods for Fully Stiff Problems","title":"Alternative Approaches","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"If split-step methods are too expensive:","category":"page"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Try stabilized explicit methods (SROCK family)\nConsider method of lines for PDE problems\nUse shorter time intervals with restarts\nReformulate problem to reduce stiffness","category":"page"},{"location":"stiff/split_step_methods/#References","page":"Split-Step Methods for Fully Stiff Problems","title":"References","text":"","category":"section"},{"location":"stiff/split_step_methods/","page":"Split-Step Methods for Fully Stiff Problems","title":"Split-Step Methods for Fully Stiff Problems","text":"Implicit-explicit splitting schemes for SDEs\nStochastic operator splitting methods","category":"page"},{"location":"stiff/implicit_methods/#Implicit-Methods-for-Stiff-SDEs","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"When SDEs have stiff drift terms, explicit methods may require impractically small time steps for stability. Implicit methods treat the drift term implicitly while keeping the diffusion explicit, providing excellent stability properties.","category":"page"},{"location":"stiff/implicit_methods/#Recommended-Stiff-Methods","page":"Implicit Methods for Stiff SDEs","title":"Recommended Stiff Methods","text":"","category":"section"},{"location":"stiff/implicit_methods/#SKenCarp-Stochastic-KenCarp-(Highly-Recommended-for-Stiff-Additive-Noise)","page":"Implicit Methods for Stiff SDEs","title":"SKenCarp - Stochastic KenCarp (Highly Recommended for Stiff Additive Noise)","text":"","category":"section"},{"location":"stiff/implicit_methods/#StochasticDiffEq.SKenCarp","page":"Implicit Methods for Stiff SDEs","title":"StochasticDiffEq.SKenCarp","text":"SKenCarp(;chunk_size=0, autodiff=true, diff_type=Val{:central}, \n         standardtag=Val{true}(), concrete_jac=nothing, precs=DEFAULT_PRECS,\n         linsolve=nothing, nlsolve=NLNewton(), smooth_est=true, \n         extrapolant=:min_correct, new_jac_conv_bound=1e-3, \n         controller=:Predictive, ode_error_est=true)\n\nSKenCarp: Stochastic KenCarp Method (Stiff) - Highly Recommended for Stiff Problems\n\nAdaptive L-stable drift-implicit method with strong order 1.5. Highly recommended for stiff problems with additive noise.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Additive noise (diagonal, non-diagonal, and scalar)\nSDE interpretation: Both Itô and Stratonovich\nStability: L-stable (excellent for stiff problems)\nImplicit: Drift-implicit (handles stiffness in drift term)\n\nWhen to Use\n\nHighly recommended for stiff additive noise problems\nWhen the drift term f(u,p,t) is stiff\nFor problems requiring high accuracy with stiff dynamics\nWhen implicit treatment of the drift is necessary for stability\nBest choice for stiff problems with additive noise structure\n\nAlgorithm Description\n\nSKenCarp applies implicit treatment to the drift term while keeping the diffusion explicit. This provides excellent stability for stiff SDEs with additive noise.\n\nStiffness and Stability\n\nL-stable: Excellent for stiff problems\nHandles large negative eigenvalues in the drift term\nMaintains accuracy while providing stability\n\nConfiguration Options\n\nLinear solver options via linsolve parameter\nNonlinear solver options via nlsolve parameter\nJacobian computation control via autodiff and related parameters\nStep size control via controller parameter\n\nReferences\n\nBased on KenCarp methods from OrdinaryDiffEq.jl\nAdapted for stochastic problems with additive noise\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_methods/#Basic-Implicit-Methods","page":"Implicit Methods for Stiff SDEs","title":"Basic Implicit Methods","text":"","category":"section"},{"location":"stiff/implicit_methods/#ImplicitEM-Implicit-Euler-Maruyama","page":"Implicit Methods for Stiff SDEs","title":"ImplicitEM - Implicit Euler-Maruyama","text":"","category":"section"},{"location":"stiff/implicit_methods/#StochasticDiffEq.ImplicitEM","page":"Implicit Methods for Stiff SDEs","title":"StochasticDiffEq.ImplicitEM","text":"ImplicitEM(;chunk_size=0, autodiff=true, diff_type=Val{:central},\n           standardtag=Val{true}(), concrete_jac=nothing, precs=DEFAULT_PRECS,\n           linsolve=nothing, nlsolve=NLNewton(), extrapolant=:constant,\n           theta=1, symplectic=false, new_jac_conv_bound=1e-3, \n           controller=:Predictive)\n\nImplicitEM: Implicit Euler-Maruyama Method (Stiff)\n\nDrift-implicit version of the Euler-Maruyama method with theta-method treatment of the drift term.\n\nMethod Properties\n\nStrong Order: 0.5 (Itô sense)\nWeak Order: 1.0\nTime stepping: Adaptive (1.0/1.5 heuristic)\nNoise types: All forms (non-diagonal, scalar, colored noise)\nSDE interpretation: Itô\nImplicit treatment: Drift term only (diffusion remains explicit)\n\nParameters\n\ntheta::Real = 1: Implicitness parameter (0=explicit, 1=fully implicit, 0.5=trapezoidal)\nsymplectic::Bool = false: When true and theta=0.5, uses symplectic implicit midpoint\nLinear/nonlinear solver options via linsolve and nlsolve\n\nWhen to Use\n\nFor mildly stiff SDEs where drift term causes stability issues\nWhen explicit methods require very small time steps\nAs a robust fallback for difficult problems\nWhen all noise types need to be supported\n\nTheta Method Variants\n\ntheta = 0: Explicit Euler (not recommended, use EM instead)\ntheta = 0.5: Trapezoidal rule (second order accurate for deterministic part)\ntheta = 1: Backward Euler (default, maximum stability)\n\nSymplectic Option\n\nWhen symplectic=true and theta=0.5, the method preserves the symplectic structure in distribution for appropriate problems.\n\nAlgorithm Description\n\nTreats the SDE du = f(u,t)dt + g(u,t)dW using:\n\nu_{n+1} = u_n + theta*f(u_{n+1},t_{n+1})*dt + (1-theta)*f(u_n,t_n)*dt + g(u_n,t_n)*dW_n\n\nReferences\n\nStandard implicit methods adapted for SDEs\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_methods/#ImplicitEulerHeun-Implicit-Euler-Heun-(Stratonovich)","page":"Implicit Methods for Stiff SDEs","title":"ImplicitEulerHeun - Implicit Euler-Heun (Stratonovich)","text":"","category":"section"},{"location":"stiff/implicit_methods/#StochasticDiffEq.ImplicitEulerHeun","page":"Implicit Methods for Stiff SDEs","title":"StochasticDiffEq.ImplicitEulerHeun","text":"ImplicitEulerHeun(;chunk_size=0, autodiff=true, diff_type=Val{:central},\n                  standardtag=Val{true}(), concrete_jac=nothing, precs=DEFAULT_PRECS,\n                  linsolve=nothing, nlsolve=NLNewton(), extrapolant=:constant,\n                  theta=1, symplectic=false, new_jac_conv_bound=1e-3, \n                  controller=:Predictive)\n\nImplicitEulerHeun: Implicit Euler-Heun Method (Stiff)\n\nDrift-implicit version of the Euler-Heun method for Stratonovich SDEs with stiff drift terms.\n\nMethod Properties\n\nStrong Order: 0.5 (Stratonovich sense)\nWeak Order: 1.0\nTime stepping: Adaptive (1.0/1.5 heuristic)\nNoise types: All forms (non-diagonal, scalar, colored noise)\nSDE interpretation: Stratonovich\nImplicit treatment: Drift term only (diffusion remains explicit)\n\nParameters\n\ntheta::Real = 1: Implicitness parameter (0=explicit, 1=fully implicit, 0.5=trapezoidal)\nsymplectic::Bool = false: When true and theta=1, uses symplectic implicit midpoint\nLinear/nonlinear solver options via linsolve and nlsolve\n\nWhen to Use\n\nStiff Stratonovich SDEs where drift term causes stability issues\nWhen working in Stratonovich interpretation with stiff dynamics\nAlternative to ImplicitEM for Stratonovich problems\nWhen all noise types need to be supported in Stratonovich form\n\nTheta Method Variants\n\ntheta = 0.5: Trapezoidal rule (default, good accuracy/stability balance)\ntheta = 1: Backward Euler (maximum stability)\n\nSymplectic Option\n\nWhen symplectic=true and theta=1, preserves symplectic structure in distribution for appropriate Stratonovich problems.\n\nReferences\n\nImplicit methods for stiff SDEs in Stratonovich interpretation\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_methods/#ImplicitRKMil-Implicit-Runge-Kutta-Milstein","page":"Implicit Methods for Stiff SDEs","title":"ImplicitRKMil - Implicit Runge-Kutta Milstein","text":"","category":"section"},{"location":"stiff/implicit_methods/#StochasticDiffEq.ImplicitRKMil","page":"Implicit Methods for Stiff SDEs","title":"StochasticDiffEq.ImplicitRKMil","text":"ImplicitRKMil(;chunk_size=0, autodiff=true, diff_type=Val{:central},\n              standardtag=Val{true}(), concrete_jac=nothing, precs=DEFAULT_PRECS,\n              linsolve=nothing, nlsolve=NLNewton(), extrapolant=:constant,\n              theta=1, symplectic=false, new_jac_conv_bound=1e-3, \n              controller=:Predictive, interpretation=AlgorithmInterpretation.Ito)\n\nImplicitRKMil: Implicit Runge-Kutta Milstein Method (Stiff)\n\nDrift-implicit Runge-Kutta Milstein method achieving order 1.0 for stiff problems with diagonal/scalar noise.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: Depends on tableau\nTime stepping: Adaptive (1.5/2.0 heuristic)\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Configurable (Itô or Stratonovich)\nImplicit treatment: Drift term only (diffusion remains explicit)\n\nParameters\n\ntheta::Real = 1: Implicitness parameter (0.5=trapezoidal, 1=backward Euler)\nsymplectic::Bool = false: When true and theta=0.5, uses symplectic implicit midpoint\ninterpretation: Choose AlgorithmInterpretation.Ito (default) or AlgorithmInterpretation.Stratonovich\nLinear/nonlinear solver options via linsolve and nlsolve\n\nWhen to Use\n\nStiff problems requiring higher accuracy than ImplicitEM\nWhen strong order 1.0 is needed with implicit stability\nDiagonal or scalar noise problems with stiff drift\nAlternative to SKenCarp for non-additive noise\n\nRestrictions\n\nOnly works with diagonal or scalar noise\nFor non-diagonal noise, use ISSEM/ISSEulerHeun\nFor additive noise, prefer SKenCarp\n\nAlgorithm Features\n\nHigher order accuracy than ImplicitEM\nMilstein correction for improved strong convergence\nConfigurable interpretation (Itô/Stratonovich)\n\nReferences\n\nImplicit Milstein methods for stiff SDEs\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_methods/#Split-Step-Implicit-Methods","page":"Implicit Methods for Stiff SDEs","title":"Split-Step Implicit Methods","text":"","category":"section"},{"location":"stiff/implicit_methods/#ISSEM-Implicit-Split-Step-Euler-Maruyama","page":"Implicit Methods for Stiff SDEs","title":"ISSEM - Implicit Split-Step Euler-Maruyama","text":"","category":"section"},{"location":"stiff/implicit_methods/#StochasticDiffEq.ISSEM","page":"Implicit Methods for Stiff SDEs","title":"StochasticDiffEq.ISSEM","text":"ISSEM(;chunk_size=0, autodiff=true, diff_type=Val{:central},\n      standardtag=Val{true}(), concrete_jac=nothing, precs=DEFAULT_PRECS,\n      linsolve=nothing, nlsolve=NLNewton(), extrapolant=:constant,\n      theta=1, symplectic=false, new_jac_conv_bound=1e-3, \n      controller=:Predictive)\n\nISSEM: Implicit Split-Step Euler-Maruyama Method (Stiff)\n\nFully implicit split-step method for handling stiffness in both drift and diffusion terms.\n\nMethod Properties\n\nStrong Order: 0.5 (Itô sense)\nWeak Order: 1.0\nTime stepping: Adaptive (1.0/1.5 heuristic)\nNoise types: All forms (non-diagonal, scalar, colored noise)\nSDE interpretation: Itô\nImplicit treatment: Both drift and diffusion terms (fully implicit)\n\nParameters\n\ntheta::Real = 1: Implicitness parameter for drift term\nsymplectic::Bool = false: When true and theta=0.5, uses symplectic implicit midpoint\nLinear/nonlinear solver options via linsolve and nlsolve\n\nWhen to Use\n\nRecommended for stiff Itô problems with large noise terms\nWhen both drift and diffusion cause stability issues\nProblems where ImplicitEM and ImplicitRKMil are insufficient\nFully stiff SDEs requiring implicit treatment of everything\n\nAlgorithm Description\n\nApplies implicit treatment to both drift and diffusion using split-step approach:\n\nStep 1: Handle drift implicitly\nStep 2: Handle diffusion implicitly\n\nFully Implicit Features\n\nCan handle stiffness in both drift and diffusion\nMore expensive than drift-only implicit methods\nMost robust for extremely stiff problems\nRequires solving nonlinear systems for both terms\n\nReferences\n\nSplit-step implicit methods for fully stiff SDEs\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_methods/#ISSEulerHeun-Implicit-Split-Step-Euler-Heun","page":"Implicit Methods for Stiff SDEs","title":"ISSEulerHeun - Implicit Split-Step Euler-Heun","text":"","category":"section"},{"location":"stiff/implicit_methods/#StochasticDiffEq.ISSEulerHeun","page":"Implicit Methods for Stiff SDEs","title":"StochasticDiffEq.ISSEulerHeun","text":"ISSEulerHeun(;chunk_size=0, autodiff=true, diff_type=Val{:central},\n             standardtag=Val{true}(), concrete_jac=nothing, precs=DEFAULT_PRECS,\n             linsolve=nothing, nlsolve=NLNewton(), extrapolant=:constant,\n             theta=1, symplectic=false, new_jac_conv_bound=1e-3, \n             controller=:Predictive)\n\nISSEulerHeun: Implicit Split-Step Euler-Heun Method (Stiff)\n\nFully implicit split-step method for Stratonovich SDEs with stiffness in both drift and diffusion terms.\n\nMethod Properties\n\nStrong Order: 0.5 (Stratonovich sense)\nWeak Order: 1.0\nTime stepping: Adaptive (1.0/1.5 heuristic)\nNoise types: All forms (non-diagonal, scalar, colored noise)\nSDE interpretation: Stratonovich\nImplicit treatment: Both drift and diffusion terms (fully implicit)\n\nParameters\n\ntheta::Real = 1: Implicitness parameter for drift term\nsymplectic::Bool = false: When true and theta=0.5, uses symplectic implicit midpoint\nLinear/nonlinear solver options via linsolve and nlsolve\n\nWhen to Use\n\nRecommended for stiff Stratonovich problems with large noise terms\nWhen both drift and diffusion cause stability issues in Stratonovich form\nStratonovich problems where ImplicitEulerHeun is insufficient\nFully stiff Stratonovich SDEs\n\nAlgorithm Description\n\nStratonovich analog of ISSEM with fully implicit treatment of both drift and diffusion terms using split-step approach.\n\nFully Implicit Features\n\nHandles stiffness in both drift and diffusion for Stratonovich SDEs\nMost expensive but most robust for Stratonovich stiff problems\nRequires solving nonlinear systems for both drift and diffusion\n\nReferences\n\nSplit-step implicit methods for fully stiff Stratonovich SDEs\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_methods/#Method-Selection-Guide","page":"Implicit Methods for Stiff SDEs","title":"Method Selection Guide","text":"","category":"section"},{"location":"stiff/implicit_methods/#Problem-Classification:","page":"Implicit Methods for Stiff SDEs","title":"Problem Classification:","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"Mildly stiff drift: ImplicitEM, ImplicitRKMil\nStiff additive noise: SKenCarp (highly recommended)\nFully stiff (including diffusion): ISSEM, ISSEulerHeun\nStratonovich problems: ImplicitEulerHeun, ISSEulerHeun","category":"page"},{"location":"stiff/implicit_methods/#Performance-Ranking-for-Stiff-Problems:","page":"Implicit Methods for Stiff SDEs","title":"Performance Ranking for Stiff Problems:","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"SKenCarp - Best for stiff problems with additive noise\nISSEM/ISSEulerHeun - For fully stiff problems\nImplicitRKMil - Higher order for mildly stiff problems\nImplicitEM - Robust fallback option","category":"page"},{"location":"stiff/implicit_methods/#Understanding-Stiffness-in-SDEs","page":"Implicit Methods for Stiff SDEs","title":"Understanding Stiffness in SDEs","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"Drift Stiffness: Large negative eigenvalues in the drift term f(u,t) requiring small time steps for explicit stability.","category":"page"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"Diffusion Stiffness: Large coefficients in the diffusion term g(u,t) causing stability issues.","category":"page"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"Detection: If explicit methods require very small dt or produce unstable solutions, try implicit methods.","category":"page"},{"location":"stiff/implicit_methods/#Configuration-Options","page":"Implicit Methods for Stiff SDEs","title":"Configuration Options","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"All implicit methods share common configuration parameters:","category":"page"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"# Linear solver options\nImplicitEM(linsolve = KrylovJL_GMRES())\n\n# Nonlinear solver options  \nImplicitEM(nlsolve = NLNewton(max_iter = 20))\n\n# Jacobian computation\nImplicitEM(autodiff = true, chunk_size = 4)\n\n# Theta method parameter\nImplicitEM(theta = 0.5)  # Trapezoidal rule","category":"page"},{"location":"stiff/implicit_methods/#Symplectic-Methods","page":"Implicit Methods for Stiff SDEs","title":"Symplectic Methods","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"For Hamiltonian SDEs, use symplectic variants:","category":"page"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"SImplicitMidpoint()  # Symplectic implicit midpoint\nSTrapezoid()        # Symplectic trapezoidal rule","category":"page"},{"location":"stiff/implicit_methods/#Performance-Tips","page":"Implicit Methods for Stiff SDEs","title":"Performance Tips","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"Jacobian: Provide analytical Jacobian when possible\nLinear solver: Choose appropriate solver for problem structure\nPreconditioning: Use preconditioners for large systems\nTheta parameter: θ=0.5 often provides good accuracy/stability balance","category":"page"},{"location":"stiff/implicit_methods/#References","page":"Implicit Methods for Stiff SDEs","title":"References","text":"","category":"section"},{"location":"stiff/implicit_methods/","page":"Implicit Methods for Stiff SDEs","title":"Implicit Methods for Stiff SDEs","text":"Standard implicit ODE methods adapted to SDEs\nMilstein, G.N., \"Numerical Integration of Stochastic Differential Equations\"","category":"page"},{"location":"nonstiff/sra_sri_methods/#SRA/SRI-Methods-Stochastic-Runge-Kutta","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"The SRA (Stochastic Runge-Kutta for Additive noise) and SRI (Stochastic Runge-Kutta for Itô) methods provide high-order adaptive solvers for different noise structures. These are among the most effective methods for their respective problem classes.","category":"page"},{"location":"nonstiff/sra_sri_methods/#Recommended-Methods","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Recommended Methods","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#SOSRI-Stability-Optimized-SRI-(Recommended)","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SOSRI - Stability-Optimized SRI (Recommended)","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SOSRI","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SOSRI","text":"SOSRI()\n\nSOSRI: Stability-Optimized SRI Method (Nonstiff) - Recommended\n\nThe Stability-Optimized Stochastic Runge-Kutta method. This is the recommended method for general-purpose solving of diagonal/scalar Itô SDEs.\n\nMethod Properties\n\nStrong Order: 1.5 (for diagonal/scalar noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Itô\nStability: Optimized for high tolerances and robust to mild stiffness\n\nWhen to Use\n\nRecommended as first choice for diagonal/scalar Itô SDEs\nWhen high accuracy is required (strong order 1.5)\nFor problems with mild stiffness\nWhen using high tolerances (method is stable)\nFor most general SDE applications\n\nAlgorithm Description\n\nSOSRI is a stability-optimized version of the SRI methods with specially chosen coefficients to improve stability properties. It provides excellent performance for the most common class of SDE problems.\n\nRestrictions\n\nOnly works with diagonal or scalar noise\nFor non-diagonal noise, use other methods like RKMilCommute or LambaEM\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SOSRA-Stability-Optimized-SRA-(Optimal-for-Additive-Noise)","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SOSRA - Stability-Optimized SRA (Optimal for Additive Noise)","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SOSRA","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SOSRA","text":"SOSRA()\n\nSOSRA: Stability-Optimized SRA Method (Nonstiff) - Optimal for Additive Noise\n\nStability-optimized adaptive Stochastic Runge-Kutta method for additive noise problems. This is the optimal choice for additive noise SDEs.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Additive noise (diagonal, non-diagonal, and scalar)\nSDE interpretation: Both Itô and Stratonovich\nStability: Optimized for high tolerances and robust to stiffness\n\nWhen to Use\n\nOptimal choice for additive noise problems: du = f(u,p,t)dt + σ dW\nWhen the diffusion term is independent of the solution u\nFor problems requiring high accuracy with additive noise\nWhen using high tolerances (method is stable)\nFor both Itô and Stratonovich interpretations\n\nAlgorithm Description\n\nSOSRA is a stability-optimized version of the SRA (Stochastic Runge-Kutta for Additive noise) methods. It exploits the special structure of additive noise to achieve better performance and stability.\n\nAdditive Noise Structure\n\nSpecialized for SDEs of the form:\n\ndu = f(u,p,t)dt + σ(t) dW\n\nwhere the diffusion σ does not depend on the solution u.\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#Alternative-SRI-Methods","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Alternative SRI Methods","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#SRIW1-SRI-Weak-Order-2","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRIW1 - SRI Weak Order 2","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRIW1","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRIW1","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRIW1()\n\nSRIW1: Stochastic Runge-Kutta W1 Method (Nonstiff)\n\nAdaptive stochastic Runge-Kutta method with strong order 1.5 and weak order 2.0 for diagonal/scalar Itô SDEs.\n\nMethod Properties\n\nStrong Order: 1.5 (for diagonal/scalar noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Itô\n\nWhen to Use\n\nStandard choice for diagonal/scalar Itô SDEs\nWhen proven theoretical properties are important\nAlternative to SOSRI when stability optimization is not needed\nFor problems requiring exactly weak order 2.0\n\nAlgorithm Features\n\nEmbedded error estimation for adaptive stepping\nWell-established theoretical foundation\nGood balance of accuracy and efficiency\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SRIW2-SRI-Weak-Order-3","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRIW2 - SRI Weak Order 3","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRIW2","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRIW2","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRIW2()\n\nSRIW2: Stochastic Runge-Kutta W2 Method (Nonstiff)\n\nAdaptive stochastic Runge-Kutta method with strong order 1.5 and weak order 3.0 for diagonal/scalar Itô SDEs.\n\nMethod Properties\n\nStrong Order: 1.5 (for diagonal/scalar noise)\nWeak Order: 3.0\nTime stepping: Adaptive\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Itô\n\nWhen to Use\n\nWhen weak order 3.0 convergence is required\nFor Monte Carlo simulations needing high weak accuracy\nProblems where weak convergence is more important than strong\nWhen computational cost per step is acceptable for higher weak order\n\nAlgorithm Features\n\nHighest weak order in the SRI family\nMore expensive per step than SRIW1\nExcellent for statistical calculations and expectations\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SOSRI2-Alternative-Stability-Optimized-SRI","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SOSRI2 - Alternative Stability-Optimized SRI","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SOSRI2","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SOSRI2","text":"SOSRI2()\n\nSOSRI2: Alternative Stability-Optimized SRI Method (Nonstiff)\n\nAlternative stability-optimized adaptive strong order 1.5 method with different stability characteristics than SOSRI.\n\nMethod Properties\n\nStrong Order: 1.5 (for diagonal/scalar noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Itô\nStability: Optimized for high tolerances and robust to stiffness\n\nWhen to Use\n\nAlternative to SOSRI with different stability properties\nWhen SOSRI performance is unsatisfactory\nFor benchmarking stability-optimized methods\nProblems requiring different stability characteristics\n\nAlgorithm Features\n\nDifferent stability optimization than SOSRI\nMay perform better on certain problem types\nMaintains high tolerance robustness\n\nReferences\n\nStability-optimized SRI methods\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#Alternative-SRA-Methods","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Alternative SRA Methods","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#SRA1-Original-SRA-Method","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA1 - Original SRA Method","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRA1","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRA1","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRA1()\n\nSRA1: Stochastic Runge-Kutta A1 Method (Nonstiff)\n\nAdaptive strong order 1.5 method for additive Itô and Stratonovich SDEs with weak order 2.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Additive noise (diagonal, non-diagonal, and scalar)\nSDE interpretation: Both Itô and Stratonovich\n\nWhen to Use\n\nStandard choice for additive noise problems\nWhen proven theoretical properties are important\nAlternative to SOSRA when stability optimization is not needed\nFor both Itô and Stratonovich problems with additive noise\n\nAdditive Noise Structure\n\nSpecialized for SDEs of the form:\n\ndu = f(u,p,t)dt + σ(p,t) dW\n\nwhere diffusion σ doesn't depend on solution u.\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SRA2-SRA-Method-Version-2","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA2 - SRA Method Version 2","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRA2","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRA2","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRA2()\n\nSRA2: Stochastic Runge-Kutta A2 Method (Nonstiff)\n\nAlternative adaptive strong order 1.5 method for additive noise problems with different coefficients.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Additive noise (diagonal, non-diagonal, and scalar)\nSDE interpretation: Both Itô and Stratonovich\n\nWhen to Use\n\nAlternative to SRA1 with different stability/accuracy characteristics\nWhen SRA1 performance is unsatisfactory\nFor benchmarking different SRA variants\nResearch and comparison studies\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SRA3-SRA-Method-with-Weak-Order-3","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA3 - SRA Method with Weak Order 3","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRA3","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRA3","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRA3()\n\nSRA3: Stochastic Runge-Kutta A3 Method (Nonstiff)\n\nAdaptive strong order 1.5 method for additive noise problems with weak order 3.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: 3.0\nTime stepping: Adaptive\nNoise types: Additive noise (non-diagonal and scalar)\nSDE interpretation: Both Itô and Stratonovich\n\nWhen to Use\n\nWhen weak order 3.0 convergence is required for additive noise\nFor Monte Carlo simulations needing highest weak accuracy\nProblems where weak convergence dominates computational cost\nWhen computational cost per step is acceptable for higher weak order\n\nRestrictions\n\nDoes not handle diagonal additive noise (use SRA1/SRA2 instead)\nLimited to non-diagonal and scalar additive noise structures\n\nAlgorithm Features\n\nHighest weak order in the SRA family\nMore expensive per step than SRA1/SRA2\nExcellent for statistical calculations requiring high weak accuracy\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SOSRA2-Alternative-Stability-Optimized-SRA","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SOSRA2 - Alternative Stability-Optimized SRA","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SOSRA2","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SOSRA2","text":"SOSRA2()\n\nSOSRA2: Stability-Optimized SRA Method Version 2 (Nonstiff)\n\nAlternative stability-optimized adaptive SRA method for additive noise problems.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: 2.0\nTime stepping: Adaptive\nNoise types: Additive noise (diagonal, non-diagonal, and scalar)\nSDE interpretation: Both Itô and Stratonovich\nStability: Optimized for high tolerances and robust to stiffness\n\nWhen to Use\n\nAlternative to SOSRA for additive noise problems\nDifferent stability characteristics may be preferred for specific problems\nWhen SOSRA performance is unsatisfactory\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#Configurable-Methods","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Configurable Methods","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#SRA-Configurable-SRA-with-Custom-Tableaux","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA - Configurable SRA with Custom Tableaux","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRA","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRA","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRA(;tableau=constructSRA1())\n\nSRA: Configurable Stochastic Runge-Kutta for Additive Noise (Nonstiff)\n\nConfigurable adaptive strong order 1.5 method for additive noise problems with customizable tableaux.\n\nMethod Properties\n\nStrong Order: 1.5 (for additive noise)\nWeak Order: Depends on tableau (typically 2.0)\nTime stepping: Adaptive\nNoise types: Additive noise (diagonal, non-diagonal, and scalar)\nSDE interpretation: Both Itô and Stratonovich\n\nParameters\n\ntableau: Tableau specification (default: constructSRA1())\n\nWhen to Use\n\nWhen custom tableaux are needed for additive noise problems\nFor research and experimentation with SRA methods\nWhen default methods don't provide desired characteristics\nFor benchmarking different SRA variants\n\nAvailable Tableaux\n\nconstructSRA1(): Default SRA1 tableau\nCustom tableaux can be constructed for specialized applications\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#SRI-Configurable-SRI-with-Custom-Tableaux","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRI - Configurable SRI with Custom Tableaux","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#StochasticDiffEq.SRI","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"StochasticDiffEq.SRI","text":"Rößler A., Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations, SIAM J. Numer. Anal., 48 (3), pp. 922–952. DOI:10.1137/09076636X\n\nSRI(;tableau=constructSRIW1(), error_terms=4)\n\nSRI: Configurable Stochastic Runge-Kutta for Itô SDEs (Nonstiff)\n\nConfigurable adaptive strong order 1.5 method for diagonal/scalar Itô SDEs with customizable tableaux.\n\nMethod Properties\n\nStrong Order: 1.5 (for diagonal/scalar noise)\nWeak Order: Depends on tableau (typically 2.0)\nTime stepping: Adaptive\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Itô\n\nParameters\n\ntableau: Tableau specification (default: constructSRIW1())\nerror_terms::Int = 4: Number of error terms for adaptive stepping\n\nWhen to Use\n\nWhen custom tableaux are needed for diagonal/scalar problems\nFor research and experimentation with SRI methods\nWhen default methods don't provide desired characteristics\nFor benchmarking different SRI variants\n\nAvailable Tableaux\n\nconstructSRIW1(): Default SRIW1 tableau\nCustom tableaux can be constructed for specialized applications\n\nReferences\n\nRößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/sra_sri_methods/#Method-Selection-Guide","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Method Selection Guide","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/#For-Diagonal/Scalar-Noise:","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"For Diagonal/Scalar Noise:","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"First choice: SOSRI - Best overall performance and stability\nAlternative: SRIW1 - Standard SRI method\nHigh weak order: SRIW2 - When weak order 3 is needed","category":"page"},{"location":"nonstiff/sra_sri_methods/#For-Additive-Noise:","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"For Additive Noise:","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"First choice: SOSRA - Optimal for additive noise structure\nAlternative: SRA1 - Standard SRA method\nHigh weak order: SRA3 - When weak order 3 is needed","category":"page"},{"location":"nonstiff/sra_sri_methods/#Performance-Characteristics:","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Performance Characteristics:","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"SOSRI/SOSRA: Stability-optimized, robust to high tolerances\nSRIWx/SRAx: Standard methods with proven theoretical properties\nSRA/SRI: Allow custom tableaux for specialized applications","category":"page"},{"location":"nonstiff/sra_sri_methods/#Theoretical-Foundation","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"Theoretical Foundation","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"The SRA and SRI methods are based on stochastic Runge-Kutta theory:","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"SRA Methods exploit the additive noise structure:","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"du = f(u,t)dt + σ(t)dW","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"Where the diffusion σ doesn't depend on the solution u.","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"SRI Methods handle the general diagonal case:","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"du = f(u,t)dt + g(u,t)dW","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"Where each component has independent noise.","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"Both method families achieve:","category":"page"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"Strong order 1.5 convergence\nWeak order 2.0 or higher\nAdaptive time stepping with embedded error estimation\nA-stable or L-stable properties (for optimized versions)","category":"page"},{"location":"nonstiff/sra_sri_methods/#References","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"References","text":"","category":"section"},{"location":"nonstiff/sra_sri_methods/","page":"SRA/SRI Methods - Stochastic Runge-Kutta","title":"SRA/SRI Methods - Stochastic Runge-Kutta","text":"Rößler A., \"Runge–Kutta Methods for the Strong Approximation of Solutions of Stochastic Differential Equations\", SIAM J. Numer. Anal., 48 (3), pp. 922–952","category":"page"},{"location":"misc/#Miscellaneous-Methods","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"This page covers specialized methods for particular types of problems or applications.","category":"page"},{"location":"misc/#Composite-Algorithms","page":"Miscellaneous Methods","title":"Composite Algorithms","text":"","category":"section"},{"location":"misc/#StochasticCompositeAlgorithm-Multi-Method-Solving","page":"Miscellaneous Methods","title":"StochasticCompositeAlgorithm - Multi-Method Solving","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.StochasticCompositeAlgorithm","page":"Miscellaneous Methods","title":"StochasticDiffEq.StochasticCompositeAlgorithm","text":"StochasticCompositeAlgorithm(algs, choice_function)\n\nStochasticCompositeAlgorithm: Multi-Method Composite Algorithm\n\nComposite algorithm that automatically switches between multiple SDE solvers based on problem characteristics.\n\nMethod Properties\n\nApproach: Multi-method solving with automatic switching\nAdaptivity: Changes methods during integration\nFlexibility: Combines strengths of different algorithms\n\nParameters\n\nalgs::Tuple: Tuple of algorithms to switch between\nchoice_function::Function: Function determining which algorithm to use\n\nWhen to Use\n\nProblems with changing characteristics during integration\nWhen different regions require different solution approaches\nCombining methods for different regimes (e.g., stiff/nonstiff)\nWhen no single method is optimal for entire domain\n\nChoice Function\n\nThe choice_function(integrator) should return an integer indicating which algorithm from algs to use:\n\nfunction choice_function(integrator)\n    if stiff_region(integrator.u, integrator.t)\n        return 1  # Use first algorithm (e.g., implicit)\n    else\n        return 2  # Use second algorithm (e.g., explicit)\n    end\nend\n\nAlgorithm Features\n\nAutomatic method switching during integration\nMaintains continuity across method transitions\nCombines computational efficiency with robustness\nCan handle complex multi-scale problems\n\nReferences\n\nComposite algorithm methodology for SDEs\n\n\n\n\n\n","category":"type"},{"location":"misc/#RODE-Methods-(Random-ODEs)","page":"Miscellaneous Methods","title":"RODE Methods (Random ODEs)","text":"","category":"section"},{"location":"misc/#RandomEM-Random-Euler-Method","page":"Miscellaneous Methods","title":"RandomEM - Random Euler Method","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.RandomEM","page":"Miscellaneous Methods","title":"StochasticDiffEq.RandomEM","text":"RandomEM()\n\nRandomEM: Random Euler Method (RODE)\n\nEuler method for Random Ordinary Differential Equations (RODEs) with random parameters.\n\nMethod Properties\n\nProblem type: Random ODEs (RODEs)\nStrong Order: 1.0 (for deterministic part)\nRandomness: Handles random parameters, not Brownian motion\nTime stepping: Fixed step size\n\nWhen to Use\n\nRandom ODEs with random parameters but no Brownian motion\nUncertainty quantification with parameter randomness\nProblems with random coefficients or initial conditions\nMonte Carlo simulation of deterministic systems with random inputs\n\nRODE vs SDE\n\nRODE: Random parameters, deterministic evolution\nSDE: Fixed parameters, stochastic (Brownian) evolution\n\nReferences\n\nRandom ordinary differential equation methods\n\n\n\n\n\n","category":"type"},{"location":"misc/#RandomHeun-Random-Heun-Method","page":"Miscellaneous Methods","title":"RandomHeun - Random Heun Method","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.RandomHeun","page":"Miscellaneous Methods","title":"StochasticDiffEq.RandomHeun","text":"RandomHeun()\n\nRandomHeun: Random Heun Method (RODE)\n\nHeun method for Random Ordinary Differential Equations with improved accuracy.\n\nMethod Properties\n\nProblem type: Random ODEs (RODEs)\nStrong Order: 2.0 (for deterministic part)\nRandomness: Handles random parameters\nTime stepping: Fixed step size\n\nWhen to Use\n\nRODEs requiring higher accuracy than RandomEM\nWhen computational cost per step is acceptable\nRandom parameter problems needing second-order accuracy\n\nReferences\n\nHigher-order methods for random ODEs\n\n\n\n\n\n","category":"type"},{"location":"misc/#RandomTamedEM-Tamed-Random-Euler","page":"Miscellaneous Methods","title":"RandomTamedEM - Tamed Random Euler","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.RandomTamedEM","page":"Miscellaneous Methods","title":"StochasticDiffEq.RandomTamedEM","text":"RandomTamedEM()\n\nRandomTamedEM: Tamed Random Euler Method (RODE)\n\nTamed Euler method for RODEs with potentially explosive behavior.\n\nMethod Properties\n\nProblem type: Random ODEs with potential blow-up\nApproach: Taming to prevent numerical explosion\nStability: Enhanced stability for unstable random systems\nTime stepping: Fixed step size with taming\n\nWhen to Use\n\nRODEs that may exhibit explosive growth\nWhen RandomEM gives unstable or explosive solutions\nRandom systems with strong nonlinearities\nProblems requiring enhanced numerical stability\n\nTaming Mechanism\n\nApplies taming technique to prevent numerical blow-up while maintaining accuracy for well-behaved solutions.\n\nReferences\n\nTamed methods for random differential equations\n\n\n\n\n\n","category":"type"},{"location":"misc/#Langevin-Dynamics","page":"Miscellaneous Methods","title":"Langevin Dynamics","text":"","category":"section"},{"location":"misc/#BAOAB-Langevin-Integrator","page":"Miscellaneous Methods","title":"BAOAB - Langevin Integrator","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.BAOAB","page":"Miscellaneous Methods","title":"StochasticDiffEq.BAOAB","text":"BAOAB(;gamma=1.0, scale_noise=true)\n\nBAOAB: Langevin Dynamics Integrator (Specialized)\n\nSpecialized integrator for Langevin dynamics in molecular dynamics simulations, particularly effective for configurational sampling.\n\nMethod Properties\n\nProblem type: Langevin dynamics (second-order SDEs)\nStructure: Position-velocity formulation\nSampling: Designed for equilibrium sampling\nTime stepping: Fixed step size\nConservation: Preserves equilibrium distributions\n\nParameters\n\ngamma::Real = 1.0: Friction coefficient\nscale_noise::Bool = true: Whether to scale noise appropriately\n\nSystem Structure\n\nDesigned for Langevin systems:\n\ndu = v dt\ndv = f(v,u) dt - γv dt + g(u)√(2γ) dW\n\nwhere:\n\nu: position coordinates\nv: velocity coordinates\nγ: friction coefficient\nf(v,u): force function\ng(u): noise scaling function\n\nWhen to Use\n\nMolecular dynamics simulations with Langevin thermostat\nConfigurational sampling of molecular systems\nEquilibrium sampling from canonical ensemble\nSecond-order SDEs with damping and noise\n\nAlgorithm Features\n\nBAOAB splitting: B(kick) - A(drift) - O(Ornstein-Uhlenbeck) - A(drift) - B(kick)\nPreserves correct equilibrium distribution\nRobust and efficient for molecular sampling\nWell-suited for long-time integration\n\nReferences\n\nLeimkuhler B., Matthews C., \"Robust and efficient configurational molecular sampling via Langevin dynamics\", J. Chem. Phys. 138, 174102 (2013)\n\n\n\n\n\n","category":"type"},{"location":"misc/#Predictor-Corrector-Methods","page":"Miscellaneous Methods","title":"Predictor-Corrector Methods","text":"","category":"section"},{"location":"misc/#PCEuler-Predictor-Corrector-Euler","page":"Miscellaneous Methods","title":"PCEuler - Predictor-Corrector Euler","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.PCEuler","page":"Miscellaneous Methods","title":"StochasticDiffEq.PCEuler","text":"PCEuler(ggprime; theta=1/2, eta=1/2)\n\nPCEuler: Predictor-Corrector Euler Method (Nonstiff)\n\nA predictor-corrector variant of the Euler-Maruyama method requiring analytic derivatives of the diffusion term, with adjustable implicitness parameters for drift-diffusion coupling.\n\nMethod Properties\n\nStrong Order: 0.5 (in the Itô sense)\nWeak Order: 1.0\nTime stepping: Fixed time step only\nNoise types: General noise with available derivative information\nSDE interpretation: Itô only\n\nParameters\n\nggprime::Function: The required derivative of the diffusion term\nFor scalar problems: ggprime = g * ∂g/∂x\nFor multi-dimensional problems: ggprime_k = Σ_{j=1...M, i=1...D} g^(j)_i * ∂g^(j)_k/∂x_i\nwhere g^(j) corresponds to the noise vector due to the j-th noise channel\nMust match the in-place/out-of-place specification of the problem\ntheta::Real = 0.5: Degree of implicitness in the drift term (default: 0.5)\neta::Real = 0.5: Degree of implicitness in the diffusion term (default: 0.5)\n\nWhen to Use\n\nProblems requiring specific drift-diffusion coupling\nWhen analytical ggprime function is available\nSpecialized predictor-corrector applications\nWhen the derivative g*g' provides stability or accuracy benefits\n\nAlgorithm Description\n\nThe method uses a predictor-corrector approach with the specific requirement of computing the derivative of the diffusion coefficient. This additional information allows for improved handling of drift-diffusion interactions through the adjustable parameters θ and η.\n\nLimitations\n\nRequires analytical computation of ggprime (cannot be approximated)\nFixed time step only (no adaptive versions available)\nLimited to Itô interpretation\n\nReferences\n\nJentzen, A., Kloeden, P.E., \"The numerical approximation of stochastic partial differential equations\", Milan J. Math. 77, 205–244 (2009). https://doi.org/10.1007/s00032-009-0100-0\nOriginally introduced in PR #88 (commit 42e2510) by Tatsuhiro Onodera (2018)\n\n!!! warning################################################################################\n\nThe derivative `ggprime` must be computed analytically for correctness.# Rossler\nThe original paper contains a typo in the definition of ggprime - this\nimplementation follows the corrected formulation.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Integro-Integral-Form-(IIF)-Methods","page":"Miscellaneous Methods","title":"Integro-Integral-Form (IIF) Methods","text":"","category":"section"},{"location":"misc/#IIF1M,-IIF2M,-IIF1Mil-IIF-Methods","page":"Miscellaneous Methods","title":"IIF1M, IIF2M, IIF1Mil - IIF Methods","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.IIF1M","page":"Miscellaneous Methods","title":"StochasticDiffEq.IIF1M","text":"IIF1M(;nlsolve=NLSOLVEJL_SETUP())\n\nIIF1M: Integrating Factor Method 1 (Semi-Linear)\n\nFirst-order integrating factor method for semi-linear SDEs with stiff linear parts.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed or adaptive\nProblem type: Semi-linear SDEs with stiff linear components\nTreatment: Exponential integrator approach\n\nParameters\n\nnlsolve: Nonlinear solver configuration\n\nWhen to Use\n\nSemi-linear SDEs: du = (L*u + N(u))dt + g(u)dW where L is stiff linear operator\nProblems amenable to integrating factor techniques\nWhen exponential integrators are appropriate\nStiff linear parts with nonlinear perturbations\n\nAlgorithm Description\n\nApplies integrating factor exp(L*t) to handle stiff linear part exactly while treating nonlinear parts numerically.\n\nReferences\n\nIntegrating factor methods for stiff SDEs\n\n\n\n\n\n","category":"type"},{"location":"misc/#StochasticDiffEq.IIF2M","page":"Miscellaneous Methods","title":"StochasticDiffEq.IIF2M","text":"IIF2M(;nlsolve=NLSOLVEJL_SETUP())\n\nIIF2M: Integrating Factor Method 2 (Semi-Linear)\n\nSecond-order integrating factor method for semi-linear SDEs.\n\nMethod Properties\n\nStrong Order: 2.0\nWeak Order: 2.0\nTime stepping: Fixed or adaptive\nProblem type: Semi-linear SDEs with stiff linear components\nTreatment: Higher-order exponential integrator\n\nParameters\n\nnlsolve: Nonlinear solver configuration\n\nWhen to Use\n\nWhen higher accuracy than IIF1M is needed\nSemi-linear problems requiring second-order convergence\nMore expensive but more accurate than IIF1M\n\nReferences\n\nHigher-order integrating factor methods for SDEs\n\n\n\n\n\n","category":"type"},{"location":"misc/#StochasticDiffEq.IIF1Mil","page":"Miscellaneous Methods","title":"StochasticDiffEq.IIF1Mil","text":"IIF1Mil(;nlsolve=NLSOLVEJL_SETUP())\n\nIIF1Mil: Integrating Factor Milstein Method (Semi-Linear)\n\nIntegrating factor method combined with Milstein correction for semi-linear SDEs.\n\nMethod Properties\n\nStrong Order: 1.0 (with Milstein correction)\nWeak Order: 1.0\nTime stepping: Fixed or adaptive\nProblem type: Semi-linear SDEs with stiff linear components\nTreatment: Exponential integrator with Milstein correction\n\nParameters\n\nnlsolve: Nonlinear solver configuration\n\nWhen to Use\n\nSemi-linear SDEs requiring Milstein-type accuracy\nWhen both stiff linear treatment and higher-order stochastic accuracy are needed\nAlternative to IIF1M with enhanced stochastic treatment\n\nReferences\n\nIntegrating factor methods with Milstein correction\n\n\n\n\n\n","category":"type"},{"location":"misc/#Simplified-Methods","page":"Miscellaneous Methods","title":"Simplified Methods","text":"","category":"section"},{"location":"misc/#SimplifiedEM-Simplified-Euler-Maruyama","page":"Miscellaneous Methods","title":"SimplifiedEM - Simplified Euler-Maruyama","text":"","category":"section"},{"location":"misc/#StochasticDiffEq.SimplifiedEM","page":"Miscellaneous Methods","title":"StochasticDiffEq.SimplifiedEM","text":"Kloeden, P.E., Platen, E., Numerical Solution of Stochastic Differential Equations. Springer. Berlin Heidelberg (2011)\n\nSimplifiedEM()\n\nSimplifiedEM: Simplified Euler-Maruyama Method (High Weak Order)\n\nSimplified version of the Euler-Maruyama method optimized for weak convergence with reduced computational cost.\n\nMethod Properties\n\nStrong Order: Not optimized for strong convergence\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: All forms (diagonal, non-diagonal, scalar, and colored noise)\nSDE interpretation: Itô\nComputational cost: Reduced compared to standard EM\n\nWhen to Use\n\nMonte Carlo simulations where weak convergence is sufficient\nProblems where computational efficiency is more important than strong accuracy\nLarge ensemble simulations\nWhen only statistical properties (expectations, moments) are needed\n\nAlgorithm Features\n\nSimplified implementation reducing computational overhead\nMaintains weak order 1.0 convergence\nMore efficient than standard EM for weak convergence applications\nHandles general noise structures\n\nWeak vs Strong Convergence\n\nOptimized for E[f(XT)] convergence, not pathwise |XT - X_h| convergence\nIdeal for computing expectations and statistical properties\nLess suitable when individual trajectory accuracy is important\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer. Berlin Heidelberg (2011)\n\n\n\n\n\n","category":"type"},{"location":"misc/#When-to-Use-Miscellaneous-Methods","page":"Miscellaneous Methods","title":"When to Use Miscellaneous Methods","text":"","category":"section"},{"location":"misc/#StochasticCompositeAlgorithm:","page":"Miscellaneous Methods","title":"StochasticCompositeAlgorithm:","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"When problem characteristics change during integration\nCombining methods for different regimes\nAutomatic method switching based on conditions","category":"page"},{"location":"misc/#RODE-Methods:","page":"Miscellaneous Methods","title":"RODE Methods:","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"Random ordinary differential equations\nProblems with random parameters but no Brownian motion\nUncertainty quantification applications","category":"page"},{"location":"misc/#BAOAB:","page":"Miscellaneous Methods","title":"BAOAB:","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"Molecular dynamics simulations\nLangevin equations with specific structure\nWhen preserving equilibrium distributions is important","category":"page"},{"location":"misc/#IIF-Methods:","page":"Miscellaneous Methods","title":"IIF Methods:","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"Semi-linear problems with stiff linear parts\nProblems amenable to integrating factor techniques\nWhen exponential integrators are appropriate","category":"page"},{"location":"misc/#PCEuler:","page":"Miscellaneous Methods","title":"PCEuler:","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"Problems requiring specific drift-diffusion coupling\nWhen analytical ggprime function is available\nSpecialized predictor-corrector applications","category":"page"},{"location":"misc/","page":"Miscellaneous Methods","title":"Miscellaneous Methods","text":"These methods serve specific niches in stochastic computation and may be optimal for particular problem structures.","category":"page"},{"location":"nonstiff/commutative_noise/#Commutative-Noise-Methods","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"When multiple noise sources satisfy commutativity conditions, specialized methods can achieve higher accuracy and efficiency compared to general methods. These methods avoid expensive Lévy area computations while maintaining high order.","category":"page"},{"location":"nonstiff/commutative_noise/#Recommended-Commutative-Noise-Methods","page":"Commutative Noise Methods","title":"Recommended Commutative Noise Methods","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#RKMilCommute-Runge-Kutta-Milstein-for-Commutative-Noise","page":"Commutative Noise Methods","title":"RKMilCommute - Runge-Kutta Milstein for Commutative Noise","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.RKMilCommute","page":"Commutative Noise Methods","title":"StochasticDiffEq.RKMilCommute","text":"Kloeden, P.E., Platen, E., Numerical Solution of Stochastic Differential Equations. Springer. Berlin Heidelberg (2011)\n\nRKMilCommute(;interpretation=AlgorithmInterpretation.Ito, ii_approx=IICommutative())\n\nRKMilCommute: Runge-Kutta Milstein for Commutative Noise (Nonstiff) - Recommended for Commutative Noise\n\nExplicit Runge-Kutta discretization of the strong order 1.0 Milstein method specialized for commutative noise problems.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: Depends on tableau\nTime stepping: Adaptive (1.5/2.0 error estimate)\nNoise types: Commutative noise (multiple noise sources that commute)\nSDE interpretation: Configurable (Itô or Stratonovich)\n\nParameters\n\ninterpretation: Choose AlgorithmInterpretation.Ito (default) or AlgorithmInterpretation.Stratonovich\nii_approx: Iterated integral approximation method (default: IICommutative())\n\nWhen to Use\n\nRecommended for commutative noise problems\nWhen you have multiple noise sources that satisfy commutativity conditions\nFor multi-dimensional SDEs with commuting noise terms\nWhen higher order accuracy than Euler-Maruyama is needed\n\nCommutative Noise\n\nApplicable when the noise terms satisfy:\n\n[g_i, g_j] = g_i(∂g_j/∂x) - g_j(∂g_i/∂x) = 0\n\nfor all noise terms gi, gj.\n\nAlgorithm Description\n\nExtends the Milstein method to handle multiple commutative noise sources efficiently without requiring the full Lévy area computation.\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer (1992)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#RKMilGeneral-General-Milstein-for-Non-commutative-Noise","page":"Commutative Noise Methods","title":"RKMilGeneral - General Milstein for Non-commutative Noise","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.RKMilGeneral","page":"Commutative Noise Methods","title":"StochasticDiffEq.RKMilGeneral","text":"Kloeden, P.E., Platen, E., Numerical Solution of Stochastic Differential Equations. Springer. Berlin Heidelberg (2011)\n\nRKMilGeneral(;interpretation=AlgorithmInterpretation.Ito, ii_approx=IILevyArea(), c=1, p=nothing, dt=nothing)\n\nRKMilGeneral: General Runge-Kutta Milstein Method (Nonstiff)\n\nExplicit Runge-Kutta discretization of the Milstein method for general non-commutative noise problems using Lévy area approximation.\n\nMethod Properties\n\nStrong Order: 1.0 (for general noise)\nWeak Order: Depends on tableau and Lévy area approximation\nTime stepping: Adaptive\nNoise types: All forms including non-commutative noise\nSDE interpretation: Configurable (Itô or Stratonovich)\n\nParameters\n\ninterpretation: Choose AlgorithmInterpretation.Ito (default) or AlgorithmInterpretation.Stratonovich\nii_approx: Iterated integral approximation method (default: IILevyArea())\nc::Int = 1: Truncation parameter for Lévy area\np: Truncation level (computed automatically if nothing)\ndt: Used for automatic truncation level computation\n\nWhen to Use\n\nFor general non-commutative noise problems\nWhen RKMilCommute is not applicable (noise doesn't commute)\nWhen higher accuracy than Euler methods is needed\nFor complex multi-dimensional noise structures\n\nLévy Area Approximation\n\nUses LevyArea.jl for efficient computation of iterated integrals:\n\nAutomatically selects optimal algorithms\nHandles truncation for practical computation\nSupports various approximation strategies\n\nComputational Cost\n\nMore expensive than commutative methods\nLévy area computation scales with noise dimension\nAdaptive truncation balances accuracy and efficiency\n\nReferences\n\nKastner, F. and Rößler, A., \"LevyArea.jl: A Julia package for Lévy area computation\", arXiv:2201.08424\nLevyArea.jl: https://github.com/stochastics-uni-luebeck/LevyArea.jl\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#Three-Stage-Milstein-Methods","page":"Commutative Noise Methods","title":"Three-Stage Milstein Methods","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#WangLi3SMil-Family-Fixed-Step-Milstein-Methods","page":"Commutative Noise Methods","title":"WangLi3SMil Family - Fixed Step Milstein Methods","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.WangLi3SMil_A","page":"Commutative Noise Methods","title":"StochasticDiffEq.WangLi3SMil_A","text":"WangLi3SMil_A()\n\nWangLi3SMil_A: 3-Stage Milstein Method A (Nonstiff)\n\nFixed step-size explicit 3-stage Milstein method with strong and weak order 1.0 for Itô SDEs.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: Depends on tableau (typically diagonal/scalar)\nSDE interpretation: Itô\n\nWhen to Use\n\nWhen fixed step size is preferred\nFor Itô SDEs requiring order 1.0 accuracy\nPart of WangLi family - compare performance with other variants\nWhen computational cost per step is less important than simplicity\n\nReferences\n\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.WangLi3SMil_B","page":"Commutative Noise Methods","title":"StochasticDiffEq.WangLi3SMil_B","text":"WangLi3SMil_B()\n\nWangLi3SMil_B: 3-Stage Milstein Method B (Nonstiff)\n\nAlternative 3-stage Milstein method with different stability and accuracy characteristics.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: Depends on tableau (typically diagonal/scalar)\nSDE interpretation: Itô\n\nReferences\n\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.WangLi3SMil_C","page":"Commutative Noise Methods","title":"StochasticDiffEq.WangLi3SMil_C","text":"WangLi3SMil_C()\n\nWangLi3SMil_C: 3-Stage Milstein Method C (Nonstiff)\n\nThird variant in the WangLi 3-stage Milstein family.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: Depends on tableau (typically diagonal/scalar)\nSDE interpretation: Itô\n\nReferences\n\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.WangLi3SMil_D","page":"Commutative Noise Methods","title":"StochasticDiffEq.WangLi3SMil_D","text":"WangLi3SMil_D()\n\nWangLi3SMil_D: 3-Stage Milstein Method D (Nonstiff)\n\nFourth variant in the WangLi 3-stage Milstein family.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: Depends on tableau (typically diagonal/scalar)\nSDE interpretation: Itô\n\nReferences\n\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.WangLi3SMil_E","page":"Commutative Noise Methods","title":"StochasticDiffEq.WangLi3SMil_E","text":"WangLi3SMil_E()\n\nWangLi3SMil_E: 3-Stage Milstein Method E (Nonstiff)\n\nFifth variant in the WangLi 3-stage Milstein family.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: Depends on tableau (typically diagonal/scalar)\nSDE interpretation: Itô\n\nReferences\n\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#StochasticDiffEq.WangLi3SMil_F","page":"Commutative Noise Methods","title":"StochasticDiffEq.WangLi3SMil_F","text":"WangLi3SMil_F()\n\nWangLi3SMil_F: 3-Stage Milstein Method F (Nonstiff)\n\nSixth and final variant in the WangLi 3-stage Milstein family.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 1.0\nTime stepping: Fixed step size\nNoise types: Depends on tableau (typically diagonal/scalar)\nSDE interpretation: Itô\n\nWhen to Use (WangLi Family)\n\nCompare all variants (A-F) to find best performance for your problem\nFixed step applications where step size is predetermined\nBenchmarking against adaptive methods\nWhen Milstein accuracy is needed with explicit fixed steps\n\nReferences\n\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/commutative_noise/#Understanding-Commutative-Noise","page":"Commutative Noise Methods","title":"Understanding Commutative Noise","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#Commutativity-Condition","page":"Commutative Noise Methods","title":"Commutativity Condition","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Noise terms g₁, g₂, ..., gₘ are commutative if:","category":"page"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"[gᵢ, gⱼ] = gᵢ(∂gⱼ/∂x) - gⱼ(∂gᵢ/∂x) = 0","category":"page"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"for all pairs (i,j).","category":"page"},{"location":"nonstiff/commutative_noise/#Examples-of-Commutative-Noise:","page":"Commutative Noise Methods","title":"Examples of Commutative Noise:","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Additive noise: g(u,t) = σ(t) (independent of u)\nScalar multiplicative: g(u,t) = σ(t)u (same u dependence)\nDiagonal with same function: gᵢ(u,t) = σᵢ(t)h(u)","category":"page"},{"location":"nonstiff/commutative_noise/#Examples-of-Non-commutative-Noise:","page":"Commutative Noise Methods","title":"Examples of Non-commutative Noise:","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Different multiplicative terms: g₁ = σ₁u₁, g₂ = σ₂u₂\nCross-coupling: g₁ = σ₁₁u₁ + σ₁₂u₂, g₂ = σ₂₁u₁ + σ₂₂u₂","category":"page"},{"location":"nonstiff/commutative_noise/#Method-Selection-Guide","page":"Commutative Noise Methods","title":"Method Selection Guide","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#For-Commutative-Noise:","page":"Commutative Noise Methods","title":"For Commutative Noise:","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"RKMilCommute - Adaptive, excellent general choice\nWangLi3SMil methods - Fixed step, when dt is predetermined","category":"page"},{"location":"nonstiff/commutative_noise/#For-Non-commutative-Noise:","page":"Commutative Noise Methods","title":"For Non-commutative Noise:","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"RKMilGeneral - Handles general case with Lévy area\nFall back to SRI/SRA methods - More robust for complex noise","category":"page"},{"location":"nonstiff/commutative_noise/#For-Uncertain-Commutativity:","page":"Commutative Noise Methods","title":"For Uncertain Commutativity:","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Test with RKMilCommute first\nIf results seem incorrect, switch to RKMilGeneral or SRI methods","category":"page"},{"location":"nonstiff/commutative_noise/#Computational-Advantages","page":"Commutative Noise Methods","title":"Computational Advantages","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Commutative case:","category":"page"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"No Lévy area computation needed\nSimpler stochastic integrals\nHigher efficiency per step\nBetter scalability to high dimensions","category":"page"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Non-commutative case:","category":"page"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Requires Lévy area approximation\nMore expensive per step\nUses specialized algorithms (LevyArea.jl integration)","category":"page"},{"location":"nonstiff/commutative_noise/#Performance-Tips","page":"Commutative Noise Methods","title":"Performance Tips","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Verify commutativity before using specialized methods\nUse appropriate interpretation (Itô vs Stratonovich)\nConsider problem dimension - benefits increase with system size\nTest accuracy - commutative methods may be more sensitive","category":"page"},{"location":"nonstiff/commutative_noise/#Iterated-Integrals-and-Lévy-Area","page":"Commutative Noise Methods","title":"Iterated Integrals and Lévy Area","text":"","category":"section"},{"location":"nonstiff/commutative_noise/#For-Commutative-Noise-(IICommutative):","page":"Commutative Noise Methods","title":"For Commutative Noise (IICommutative):","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Only simple stochastic integrals ∫₀ᵗ dWₛ are needed.","category":"page"},{"location":"nonstiff/commutative_noise/#For-Non-commutative-Noise-(IILevyArea):","page":"Commutative Noise Methods","title":"For Non-commutative Noise (IILevyArea):","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Requires double integrals ∫₀ᵗ ∫₀ˢ dWᵤdWₛ (Lévy area).","category":"page"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"RKMilGeneral automatically chooses optimal Lévy area algorithms via LevyArea.jl.","category":"page"},{"location":"nonstiff/commutative_noise/#References","page":"Commutative Noise Methods","title":"References","text":"","category":"section"},{"location":"nonstiff/commutative_noise/","page":"Commutative Noise Methods","title":"Commutative Noise Methods","text":"Kloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\"\nWang and Li, \"Three-stage stochastic Runge-Kutta methods for stochastic differential equations\"\nKastner, F. and Rößler, A., \"LevyArea.jl\" for Lévy area computation","category":"page"},{"location":"stiff/stabilized_methods/#Stabilized-Methods-(SROCK-Family)","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Stabilized Runge-Kutta Chebyshev (SROCK) methods provide stability for mildly stiff problems through extended stability regions rather than implicit treatment. These methods are particularly effective for parabolic PDEs discretized by method of lines.","category":"page"},{"location":"stiff/stabilized_methods/#SROCK-Methods","page":"Stabilized Methods (SROCK Family)","title":"SROCK Methods","text":"","category":"section"},{"location":"stiff/stabilized_methods/#SROCK1-First-Order-Stabilized-Method","page":"Stabilized Methods (SROCK Family)","title":"SROCK1 - First Order Stabilized Method","text":"","category":"section"},{"location":"stiff/stabilized_methods/#StochasticDiffEq.SROCK1","page":"Stabilized Methods (SROCK Family)","title":"StochasticDiffEq.SROCK1","text":"SROCK1(;interpretation=AlgorithmInterpretation.Ito, eigen_est=nothing)\n\nSROCK1: First-Order Stabilized Runge-Kutta Chebyshev Method\n\nFixed step size stabilized explicit method designed for mildly stiff SDE problems, particularly effective for parabolic PDEs discretized by method of lines.\n\nMethod Properties\n\nStrong Order: 0.5 (optimized to 1.0 for scalar/diagonal noise)\nWeak Order: 1.0\nTime stepping: Fixed step size with extended stability\nNoise types: All forms (diagonal, non-diagonal, scalar, additive)\nSDE interpretation: Configurable (Itô or Stratonovich)\nStability: Extended along negative real axis\n\nParameters\n\ninterpretation: Choose AlgorithmInterpretation.Ito (default) or AlgorithmInterpretation.Stratonovich\neigen_est: Eigenvalue estimation for stability region (automatic if nothing)\n\nWhen to Use\n\nParabolic PDEs with stochastic terms\nMildly stiff problems where implicit methods are too expensive\nLarge sparse systems from method of lines\nWhen stability region extension is more important than high accuracy\n\nStability\n\nExtends stability region to approximately [-s², 0] where s is number of stages\nNumber of stages chosen based on eigenvalue estimates\nMore efficient than implicit methods for moderate stiffness\n\nReferences\n\nChebyshev methods for parabolic stochastic PDEs\nROCK methods for stiff problems\n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_methods/#SROCK2,-KomBurSROCK2,-SROCKC2-Second-Order-Methods","page":"Stabilized Methods (SROCK Family)","title":"SROCK2, KomBurSROCK2, SROCKC2 - Second Order Methods","text":"","category":"section"},{"location":"stiff/stabilized_methods/#SROCKEM-Stabilized-Euler-Maruyama","page":"Stabilized Methods (SROCK Family)","title":"SROCKEM - Stabilized Euler-Maruyama","text":"","category":"section"},{"location":"stiff/stabilized_methods/#StochasticDiffEq.SROCKEM","page":"Stabilized Methods (SROCK Family)","title":"StochasticDiffEq.SROCKEM","text":"SROCKEM(;strong_order_1=true, eigen_est=nothing)\n\nSROCKEM: ROCK-Stabilized Euler-Maruyama Method\n\nFixed step Euler-Maruyama method with first-order ROCK stabilization for handling stiff problems.\n\nMethod Properties\n\nStrong Order: 1.0 (default) or 0.5 (if strong_order_1=false)\nWeak Order: 1.0 (default) or 0.5 (if strong_order_1=false)\nTime stepping: Fixed step size with ROCK stabilization\nNoise types: 1-dimensional, diagonal, and multi-dimensional noise\nSDE interpretation: Itô only\nStability: ROCK stabilization for moderate stiffness\n\nParameters\n\nstrong_order_1::Bool = true: Use strong/weak order 1.0 (true) or 0.5 (false)\neigen_est: Eigenvalue estimation for stability (automatic if nothing)\n\nWhen to Use\n\nStiff problems where standard EM fails\nWhen ROCK stabilization is preferred over full implicit treatment\nProblems requiring Euler-Maruyama structure with enhanced stability\nMulti-dimensional stiff SDEs\n\nAlgorithm Description\n\nCombines Euler-Maruyama discretization with ROCK stabilization techniques to extend the stability region without requiring linear solves.\n\nReferences\n\nROCK stabilization techniques applied to SDEs\nStabilized Euler methods for stiff problems\n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_methods/#SKSROCK-Stabilized-Method-with-Post-Processing","page":"Stabilized Methods (SROCK Family)","title":"SKSROCK - Stabilized Method with Post-Processing","text":"","category":"section"},{"location":"stiff/stabilized_methods/#StochasticDiffEq.SKSROCK","page":"Stabilized Methods (SROCK Family)","title":"StochasticDiffEq.SKSROCK","text":"SKSROCK(;post_processing=false, eigen_est=nothing)\n\nSKSROCK: SK-SROCK Stabilized Method\n\nFixed step stabilized explicit method for stiff Itô problems with enhanced stability domain and optional post-processing.\n\nMethod Properties\n\nStrong Order: 0.5 (up to 2.0 with post-processing)\nWeak Order: 1.0 (up to 2.0 with post-processing)\nTime stepping: Fixed step size with enhanced stability\nNoise types: 1-dimensional, diagonal, and multi-dimensional noise\nSDE interpretation: Itô only\nStability: Better stability domain than SROCK1\n\nParameters\n\npost_processing::Bool = false: Enable post-processing for higher accuracy (experimental)\neigen_est: Eigenvalue estimation for stability (automatic if nothing)\n\nWhen to Use\n\nStiff Itô problems requiring better stability than SROCK1\nErgodic dynamical systems (with post-processing)\nProblems where enhanced stability domain is crucial\nWhen experimenting with post-processing techniques\n\nPost-Processing (Experimental)\n\nCan achieve order 2 accuracy for ergodic systems\nParticularly useful for Brownian dynamics\nCurrently under development - use with caution\n\nAlgorithm Features\n\nEnhanced stability compared to SROCK1\nHandles various noise structures\nOptional post-processing for specialized applications\n\nReferences\n\nSK-SROCK methods for stochastic problems\nPost-processing techniques for ergodic systems\n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_methods/#TangXiaoSROCK2-Alternative-Second-Order-Method","page":"Stabilized Methods (SROCK Family)","title":"TangXiaoSROCK2 - Alternative Second Order Method","text":"","category":"section"},{"location":"stiff/stabilized_methods/#StochasticDiffEq.TangXiaoSROCK2","page":"Stabilized Methods (SROCK Family)","title":"StochasticDiffEq.TangXiaoSROCK2","text":"TangXiaoSROCK2(;version_num=5, eigen_est=nothing)\n\nTangXiaoSROCK2: Tang-Xiao Second-Order SROCK Method\n\nFixed step size stabilized explicit method with multiple variants offering different stability domains.\n\nMethod Properties\n\nStrong Order: 1.0\nWeak Order: 2.0\nTime stepping: Fixed step size with extended stability\nNoise types: Various (depends on version)\nSDE interpretation: Itô only\nStability: Version-dependent stability domains\n\nParameters\n\nversion_num::Int = 5: Choose version 1-5 with different stability characteristics\neigen_est: Eigenvalue estimation for stability (automatic if nothing)\n\nWhen to Use\n\nWhen experimenting with different stability domains\nProblems requiring weak order 2.0 with fixed steps\nBenchmarking different ROCK variants\nNote: Currently under development\n\nVersions\n\nVersions 1-5 offer different stability domains\nVersion 5 (default) typically provides good general performance\nChoose version based on problem-specific stability requirements\n\nDevelopment Status\n\nMethod is under active development\nUse with caution in production code\nConsider more established ROCK methods for critical applications\n\nReferences\n\nTang and Xiao, \"Second-order SROCK methods for stochastic problems\"\n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_methods/#When-to-Use-Stabilized-Methods","page":"Stabilized Methods (SROCK Family)","title":"When to Use Stabilized Methods","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Ideal for:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Parabolic PDEs discretized by method of lines\nProblems with moderate stiffness (not extremely stiff)\nLarge systems where implicit methods are expensive\nWhen eigenvalue spectrum is primarily negative real","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Advantages over implicit methods:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"No linear system solves required\nBetter for large systems\nParallelizable\nNo Jacobian computation needed","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Disadvantages:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Limited to moderate stiffness\nMay require eigenvalue estimation\nNot effective for highly oscillatory problems","category":"page"},{"location":"stiff/stabilized_methods/#Stability-Regions","page":"Stabilized Methods (SROCK Family)","title":"Stability Regions","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"SROCK methods extend stability along the negative real axis:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Standard explicit: Stability region ~ [-2, 0]\nSROCK methods: Stability region ~ [-s², 0] where s is the number of stages","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"The number of stages s is chosen based on estimated eigenvalues.","category":"page"},{"location":"stiff/stabilized_methods/#Eigenvalue-Estimation","page":"Stabilized Methods (SROCK Family)","title":"Eigenvalue Estimation","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Most SROCK methods accept an eigen_est parameter:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"# Automatic estimation (default)\nSROCK1()\n\n# Manual estimation\nSROCK1(eigen_est = -100.0)  # Largest eigenvalue magnitude\n\n# Custom estimation function\nSROCK1(eigen_est = my_estimator)","category":"page"},{"location":"stiff/stabilized_methods/#Method-Selection-Guide","page":"Stabilized Methods (SROCK Family)","title":"Method Selection Guide","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"SROCK1: Basic first-order method, most robust\nSROCK2: Higher accuracy, good general choice\nSROCKEM: When Euler-Maruyama structure is preferred\nSKSROCK: Advanced features, post-processing options\nSROCKC2: Conservative second-order variant","category":"page"},{"location":"stiff/stabilized_methods/#Problem-Suitability","page":"Stabilized Methods (SROCK Family)","title":"Problem Suitability","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Well-suited:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Reaction-diffusion equations\nHeat equations with stochastic terms\nLarge sparse systems\nMethod of lines discretizations","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Not well-suited:","category":"page"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Highly stiff problems (use implicit methods)\nProblems with complex eigenvalue spectra\nSmall dense systems (overhead not justified)","category":"page"},{"location":"stiff/stabilized_methods/#Configuration-Tips","page":"Stabilized Methods (SROCK Family)","title":"Configuration Tips","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"# For PDE problems\nSROCK2(eigen_est = estimate_spectral_radius(A))\n\n# For uncertain problems, start conservatively\nSROCK1()  # Most robust\n\n# For higher accuracy\nSROCK2()  # Good balance","category":"page"},{"location":"stiff/stabilized_methods/#Performance-Considerations","page":"Stabilized Methods (SROCK Family)","title":"Performance Considerations","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Stage count increases with stiffness\nEigenvalue estimation cost\nMemory requirements for internal stages\nBetter scalability than implicit methods","category":"page"},{"location":"stiff/stabilized_methods/#References","page":"Stabilized Methods (SROCK Family)","title":"References","text":"","category":"section"},{"location":"stiff/stabilized_methods/","page":"Stabilized Methods (SROCK Family)","title":"Stabilized Methods (SROCK Family)","text":"Chebyshev methods for parabolic problems\nROCK methods for stiff ODEs\nStabilized explicit methods for PDEs","category":"page"},{"location":"usage/#Usage-Guide","page":"Usage","title":"Usage Guide","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This page provides guidance on using StochasticDiffEq.jl effectively.","category":"page"},{"location":"usage/#Basic-Usage","page":"Usage","title":"Basic Usage","text":"","category":"section"},{"location":"usage/#Problem-Definition","page":"Usage","title":"Problem Definition","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"StochasticDiffEq.jl uses the standard DifferentialEquations.jl problem interface:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using StochasticDiffEq\n\n# For scalar problems\nfunction f(u, p, t)  # drift\n    return μ * u\nend\n\nfunction g(u, p, t)  # diffusion  \n    return σ * u\nend\n\n# For in-place systems\nfunction f!(du, u, p, t)\n    du[1] = μ * u[1]\n    du[2] = -ν * u[2]\nend\n\nfunction g!(du, u, p, t)\n    du[1] = σ₁ * u[1]\n    du[2] = σ₂ * u[2]\nend\n\n# Create problem\nprob = SDEProblem(f, g, u0, tspan)","category":"page"},{"location":"usage/#Solver-Selection","page":"Usage","title":"Solver Selection","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Choose solvers based on your problem characteristics:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Default - good for most problems\nsol = solve(prob)\n\n# Specify solver explicitly\nsol = solve(prob, SOSRI())          # Recommended for diagonal noise\nsol = solve(prob, SOSRA())          # Optimal for additive noise  \nsol = solve(prob, SKenCarp())       # For stiff problems\nsol = solve(prob, EM())             # For maximum efficiency","category":"page"},{"location":"usage/#Algorithm-Parameters","page":"Usage","title":"Algorithm Parameters","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Most solvers accept parameters for customization:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Euler-Maruyama with step splitting\nsol = solve(prob, EM(split = true))\n\n# RKMilCommute with Stratonovich interpretation\nsol = solve(prob, RKMilCommute(interpretation = :Stratonovich))\n\n# Implicit methods with solver options\nsol = solve(prob, SKenCarp(linsolve = KrylovJL_GMRES()))","category":"page"},{"location":"usage/#Tolerances-and-Adaptive-Stepping","page":"Usage","title":"Tolerances and Adaptive Stepping","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Set absolute and relative tolerances:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"sol = solve(prob, SOSRI(), abstol = 1e-6, reltol = 1e-3)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For fixed time stepping:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"sol = solve(prob, EM(), dt = 0.01, adaptive = false)","category":"page"},{"location":"usage/#Noise-Types","page":"Usage","title":"Noise Types","text":"","category":"section"},{"location":"usage/#Diagonal-Noise","page":"Usage","title":"Diagonal Noise","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Most common case - each component has independent noise:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function g!(du, u, p, t)\n    du[1] = σ₁ * u[1]\n    du[2] = σ₂ * u[2]\nend","category":"page"},{"location":"usage/#Scalar-Noise","page":"Usage","title":"Scalar Noise","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Single noise source affects all components:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function g!(du, u, p, t)\n    du[1] = σ * u[1]\n    du[2] = σ * u[2]\nend","category":"page"},{"location":"usage/#Non-diagonal-Noise","page":"Usage","title":"Non-diagonal Noise","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Multiple noise sources with cross-terms:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function g!(du, u, p, t)\n    du[1] = σ₁₁ * u[1] + σ₁₂ * u[2]\n    du[2] = σ₂₁ * u[1] + σ₂₂ * u[2]\nend","category":"page"},{"location":"usage/#Additive-Noise","page":"Usage","title":"Additive Noise","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Noise independent of solution:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function g!(du, u, p, t)\n    du[1] = σ₁\n    du[2] = σ₂\nend","category":"page"},{"location":"usage/#Itô-vs-Stratonovich","page":"Usage","title":"Itô vs Stratonovich","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Specify interpretation when creating problems or choosing solvers:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Itô interpretation (default)\nprob = SDEProblem(f!, g!, u0, tspan, interpretation = :Ito)\n\n# Stratonovich interpretation  \nprob = SDEProblem(f!, g!, u0, tspan, interpretation = :Stratonovich)\n\n# Or at solver level\nsol = solve(prob, RKMil(interpretation = :Stratonovich))","category":"page"},{"location":"usage/#Performance-Tips","page":"Usage","title":"Performance Tips","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Use appropriate solvers: Match solver to problem type\nIn-place functions: Use f!(du,u,p,t) for better performance\nTolerances: Don't make tolerances unnecessarily strict\nStatic arrays: Use StaticArrays.jl for small systems\nGPU: Use CuArrays.jl for large problems","category":"page"},{"location":"usage/#Common-Pitfalls","page":"Usage","title":"Common Pitfalls","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Wrong noise type: Ensure solver supports your noise structure\nStiffness: Use appropriate stiff solvers for stiff problems\nCommuting noise: Use specialized solvers for better efficiency\nHigh dimensions: Consider weak convergence methods for Monte Carlo","category":"page"},{"location":"usage/#Integration-with-DifferentialEquations.jl","page":"Usage","title":"Integration with DifferentialEquations.jl","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"StochasticDiffEq.jl integrates with the broader ecosystem:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using DifferentialEquations\n\n# Callbacks\ncondition(u, t, integrator) = u[1] - 0.5\naffect!(integrator) = terminate!(integrator)\ncb = ContinuousCallback(condition, affect!)\n\nsol = solve(prob, SOSRI(), callback = cb)\n\n# Ensemble simulations\nmonte_prob = EnsembleProblem(prob)\nsim = solve(monte_prob, SOSRI(), EnsembleThreads(), trajectories = 1000)","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Tau-Leaping-Methods-for-Jump-Diffusion","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Tau-leaping methods approximate jump processes by \"leaping\" over multiple potential jump events in a single time step. These methods are essential for efficiently simulating systems with jump-diffusion processes.","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Tau-Leaping-Methods","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/#TauLeaping-Basic-Tau-Leaping","page":"Tau-Leaping Methods for Jump-Diffusion","title":"TauLeaping - Basic Tau-Leaping","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/#StochasticDiffEq.TauLeaping","page":"Tau-Leaping Methods for Jump-Diffusion","title":"StochasticDiffEq.TauLeaping","text":"TauLeaping()\n\nTauLeaping: Basic Tau-Leaping Method (Jump-Diffusion)\n\nBasic tau-leaping method for approximating jump-diffusion processes by \"leaping\" over multiple potential jump events.\n\nMethod Properties\n\nProblem type: Jump-diffusion processes\nApproach: Approximate multiple jumps per time step\nTime stepping: Fixed tau approach\nAccuracy: Depends on tau selection\n\nWhen to Use\n\nJump-diffusion systems with many small jumps\nWhen exact jump simulation is computationally prohibitive\nChemical reaction networks with fast reactions\nPopulation models with high birth-death rates\nInitial exploration of jump-diffusion problems\n\nAlgorithm Description\n\nApproximates Poisson processes by assuming constant propensities over time interval tau, then sampling number of jumps from Poisson distribution.\n\nTau Selection\n\nCritical parameter: tau should be small enough that jump rates don't change significantly over [t, t+tau].\n\nReferences\n\nGillespie, D.T., \"Approximate accelerated stochastic simulation of chemically reacting systems\"\n\n\n\n\n\n","category":"type"},{"location":"jumpdiffusion/tau_leaping/#CaoTauLeaping-Cao's-Tau-Leaping","page":"Tau-Leaping Methods for Jump-Diffusion","title":"CaoTauLeaping - Cao's Tau-Leaping","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/#StochasticDiffEq.CaoTauLeaping","page":"Tau-Leaping Methods for Jump-Diffusion","title":"StochasticDiffEq.CaoTauLeaping","text":"CaoTauLeaping()\n\nCaoTauLeaping: Cao's Adaptive Tau-Leaping Method (Jump-Diffusion)\n\nAdvanced tau-leaping method with adaptive tau selection and improved error control.\n\nMethod Properties\n\nProblem type: Jump-diffusion processes\nApproach: Adaptive tau selection with error control\nTime stepping: Adaptive tau based on error estimates\nAccuracy: Superior to basic tau-leaping\n\nWhen to Use\n\nProduction jump-diffusion simulations requiring reliability\nWhen adaptive tau selection is needed\nProblems where basic TauLeaping gives poor accuracy\nChemical reaction networks requiring precise control\n\nAlgorithm Features\n\nAdaptive tau selection based on error estimates\nBetter stability and accuracy than basic tau-leaping\nAutomatic step size control\nMore sophisticated error estimation\n\nTau Selection\n\nAutomatically adjusts tau based on:\n\nLocal error estimates\nJump rate variations\nSolution stability requirements\n\nReferences################################################################################\n\nCao, Y., Gillespie, D.T., Petzold, L.R., \"Efficient step size selection for the tau-leaping method\"# Etc.\n\n\n\n\n\n","category":"type"},{"location":"jumpdiffusion/tau_leaping/#Understanding-Jump-Diffusion-Processes","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Understanding Jump-Diffusion Processes","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Jump-diffusion processes combine:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Continuous diffusion: Standard Brownian motion terms\nJump processes: Discontinuous jumps at random times","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"General form:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"dX = μ(X,t)dt + σ(X,t)dW + ∫ h(X-,z)Ñ(dt,dz)","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Where:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"μ(X,t)dt: Drift term\nσ(X,t)dW: Diffusion term\nÑ(dt,dz): Compensated random measure (jumps)","category":"page"},{"location":"jumpdiffusion/tau_leaping/#When-to-Use-Tau-Leaping","page":"Tau-Leaping Methods for Jump-Diffusion","title":"When to Use Tau-Leaping","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Appropriate for:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Systems with many small jumps\nWhen exact jump simulation is computationally prohibitive\nChemical reaction networks\nPopulation models with birth-death processes\nFinancial models with rare events","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Not appropriate for:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Systems dominated by large, infrequent jumps\nWhen exact jump timing is critical\nSmall systems where exact methods are feasible","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Method-Characteristics","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Method Characteristics","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/#TauLeaping:","page":"Tau-Leaping Methods for Jump-Diffusion","title":"TauLeaping:","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Basic tau-leaping approximation\nFixed tau approach\nGood for initial exploration","category":"page"},{"location":"jumpdiffusion/tau_leaping/#CaoTauLeaping:","page":"Tau-Leaping Methods for Jump-Diffusion","title":"CaoTauLeaping:","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Adaptive tau selection\nMore sophisticated error control\nBetter for production simulations","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Configuration","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Configuration","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Tau-leaping methods require:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Jump rate functions: λ(X,t) for each reaction/jump type\nJump effects: How state changes with each jump\nTau selection: Time step size strategy","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"# Basic setup\nprob = JumpProblem(base_problem, aggregator, jumps...)\nsol = solve(prob, TauLeaping())\n\n# With adaptive tau\nsol = solve(prob, CaoTauLeaping(), tau_tol = 0.01)","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Accuracy-Considerations","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Accuracy Considerations","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Tau-leaping approximation quality depends on:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Jump frequency vs. tau size\nState change magnitude per jump\nSystem stiffness\nError tolerance requirements","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Rule of thumb: Tau should be small enough that jump rates don't change significantly over [t, t+tau].","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Alternative-Approaches","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Alternative Approaches","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"If tau-leaping is inadequate:","category":"page"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Exact methods: Gillespie algorithm for small systems\nHybrid methods: Combine exact and approximate regions\nMoment closure: For statistical properties only\nPiecewise deterministic: For systems with rare jumps","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Performance-Tips","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Performance Tips","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Vectorize jump computations when possible\nUse sparse representations for large systems\nTune tau carefully - too large gives poor accuracy, too small is inefficient\nMonitor jump frequencies to validate approximation","category":"page"},{"location":"jumpdiffusion/tau_leaping/#Integration-with-DifferentialEquations.jl","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Integration with DifferentialEquations.jl","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"using DifferentialEquations, StochasticDiffEq\n\n# Define base SDE\nfunction drift!(du, u, p, t)\n    # Continuous drift\nend\n\nfunction diffusion!(du, u, p, t)\n    # Continuous diffusion\nend\n\n# Define jumps\njump1 = ConstantRateJump(rate1, affect1!)\njump2 = VariableRateJump(rate2, affect2!)\n\n# Combine into jump-diffusion problem\nsde_prob = SDEProblem(drift!, diffusion!, u0, tspan)\njump_prob = JumpProblem(sde_prob, Direct(), jump1, jump2)\n\n# Solve with tau-leaping\nsol = solve(jump_prob, TauLeaping())","category":"page"},{"location":"jumpdiffusion/tau_leaping/#References","page":"Tau-Leaping Methods for Jump-Diffusion","title":"References","text":"","category":"section"},{"location":"jumpdiffusion/tau_leaping/","page":"Tau-Leaping Methods for Jump-Diffusion","title":"Tau-Leaping Methods for Jump-Diffusion","text":"Gillespie, D.T., \"Approximate accelerated stochastic simulation of chemically reacting systems\"\nCao, Y., Gillespie, D.T., Petzold, L.R., \"Efficient step size selection for the tau-leaping method\"","category":"page"},{"location":"nonstiff/basic_methods/#Basic-Nonstiff-Methods","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"","category":"section"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"This page covers the fundamental explicit methods for solving SDEs. These methods are suitable for non-stiff problems and provide the foundation for more advanced algorithms.","category":"page"},{"location":"nonstiff/basic_methods/#Euler-Maruyama-Methods","page":"Basic Nonstiff Methods","title":"Euler-Maruyama Methods","text":"","category":"section"},{"location":"nonstiff/basic_methods/#EM-Euler-Maruyama","page":"Basic Nonstiff Methods","title":"EM - Euler-Maruyama","text":"","category":"section"},{"location":"nonstiff/basic_methods/#StochasticDiffEq.EM","page":"Basic Nonstiff Methods","title":"StochasticDiffEq.EM","text":"EM: Nonstiff Method The Euler-Maruyama method is the simplest and most fundamental numerical method for solving stochastic differential equations.\n\nMethod Properties\n\nStrong Order: 0.5 (in the Itô sense)\nWeak Order: 1.0\nTime stepping: Fixed time step only\nNoise types: All forms (diagonal, non-diagonal, scalar, additive, and colored noise)\nSDE interpretation: Itô\n\nParameters\n\nsplit::Bool = true: Controls step splitting for improved stability with large diffusion eigenvalues\n\nWhen to Use\n\nFirst choice for simple SDE problems\nWhen computational efficiency is more important than accuracy\nFor problems with all noise types including non-commutative noise\nWhen step splitting is needed for stability with large diffusion terms\n\nAlgorithm Description\n\nThe method discretizes the SDE:\n\ndu = f(u,p,t)dt + g(u,p,t)dW\n\nusing the scheme:\n\nu_{n+1} = u_n + f(u_n,p,t_n)Δt + g(u_n,p,t_n)ΔW_n\n\nWhen split=true, the method uses step splitting which can improve stability for problems with large diffusion eigenvalues.\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer (1992)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/basic_methods/#EulerHeun-Euler-Heun","page":"Basic Nonstiff Methods","title":"EulerHeun - Euler-Heun","text":"","category":"section"},{"location":"nonstiff/basic_methods/#StochasticDiffEq.EulerHeun","page":"Basic Nonstiff Methods","title":"StochasticDiffEq.EulerHeun","text":"EulerHeun()\n\nEulerHeun: Euler-Heun Method (Nonstiff)\n\nThe Euler-Heun method is the Stratonovich analog of the Euler-Maruyama method, providing strong order 0.5 convergence in the Stratonovich sense.\n\nMethod Properties\n\nStrong Order: 0.5 (in the Stratonovich sense)\nWeak Order: 1.0\nTime stepping: Fixed time step only\nNoise types: All forms (diagonal, non-diagonal, scalar, additive, and colored noise)\nSDE interpretation: Stratonovich\n\nWhen to Use\n\nWhen working with Stratonovich SDEs\nFor problems naturally formulated in Stratonovich interpretation\nWhen physical interpretation requires Stratonovich calculus\nAs the Stratonovich counterpart to Euler-Maruyama\n\nAlgorithm Description\n\nFor Stratonovich SDEs:\n\ndu = f(u,p,t)dt + g(u,p,t)∘dW\n\nThe method uses:\n\nu_{n+1} = u_n + f(u_n,p,t_n)Δt + g(u_n + 0.5*g(u_n,p,t_n)ΔW_n, p, t_n)ΔW_n\n\nStratonovich vs Itô\n\nEulerHeun: For Stratonovich SDEs\nEM: For Itô SDEs\nConversion between interpretations changes the drift term\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer (1992)\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/basic_methods/#LambaEM-Adaptive-Euler-Maruyama","page":"Basic Nonstiff Methods","title":"LambaEM - Adaptive Euler-Maruyama","text":"","category":"section"},{"location":"nonstiff/basic_methods/#StochasticDiffEq.LambaEM","page":"Basic Nonstiff Methods","title":"StochasticDiffEq.LambaEM","text":"LambaEM(split=true)\n\nLambaEM: Adaptive Euler-Maruyama Method (Nonstiff)\n\nAdaptive time-stepping version of the Euler-Maruyama method with error estimation based on the work of Lamba and Rackauckas.\n\nMethod Properties\n\nStrong Order: 0.5 (in the Itô sense)\nWeak Order: 1.0\nTime stepping: Adaptive with embedded error estimation\nNoise types: All forms (diagonal, non-diagonal, scalar, additive, and colored noise)\nSDE interpretation: Itô\n\nParameters\n\nsplit::Bool = true: Controls step splitting for improved stability\n\nWhen to Use\n\nWhen adaptive time stepping is needed with basic Euler-Maruyama\nFor problems requiring error control without high-order accuracy\nWhen computational efficiency and adaptivity are both important\nFor non-commutative noise where higher-order methods aren't applicable\n\nAlgorithm Description\n\nExtends EM with adaptive time stepping using error estimation. The method computes two approximations and uses their difference to estimate local error.\n\nError Control\n\nEmbedded error estimation for adaptive stepping\nAccepts standard tolerances (abstol, reltol)\nAutomatic step size adjustment\n\nReferences\n\nBased on error estimation work by Lamba and Rackauckas\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/basic_methods/#LambaEulerHeun-Adaptive-Euler-Heun","page":"Basic Nonstiff Methods","title":"LambaEulerHeun - Adaptive Euler-Heun","text":"","category":"section"},{"location":"nonstiff/basic_methods/#StochasticDiffEq.LambaEulerHeun","page":"Basic Nonstiff Methods","title":"StochasticDiffEq.LambaEulerHeun","text":"LambaEulerHeun()\n\nLambaEulerHeun: Adaptive Euler-Heun Method (Nonstiff)\n\nAdaptive time-stepping version of the Euler-Heun method with error estimation for Stratonovich SDEs.\n\nMethod Properties\n\nStrong Order: 0.5 (in the Stratonovich sense)\nWeak Order: 1.0\nTime stepping: Adaptive with embedded error estimation\nNoise types: All forms (diagonal, non-diagonal, scalar, additive, and colored noise)\nSDE interpretation: Stratonovich\n\nWhen to Use\n\nWhen adaptive time stepping is needed for Stratonovich SDEs\nFor problems requiring error control in Stratonovich interpretation\nWhen computational efficiency and adaptivity are both important\nFor non-commutative noise in Stratonovich formulation\n\nAlgorithm Description\n\nAdaptive version of EulerHeun method with error estimation for automatic step size control.\n\nError Control\n\nEmbedded error estimation for adaptive stepping\nStandard tolerance control (abstol, reltol)\nAutomatic step size adjustment for Stratonovich problems\n\nReferences\n\nError estimation methodology by Lamba, adapted by Rackauckas\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/basic_methods/#Milstein-Methods","page":"Basic Nonstiff Methods","title":"Milstein Methods","text":"","category":"section"},{"location":"nonstiff/basic_methods/#RKMil-Runge-Kutta-Milstein","page":"Basic Nonstiff Methods","title":"RKMil - Runge-Kutta Milstein","text":"","category":"section"},{"location":"nonstiff/basic_methods/#StochasticDiffEq.RKMil","page":"Basic Nonstiff Methods","title":"StochasticDiffEq.RKMil","text":"Kloeden, P.E., Platen, E., Numerical Solution of Stochastic Differential Equations. Springer. Berlin Heidelberg (2011)\n\nRKMil(;interpretation=AlgorithmInterpretation.Ito)\n\nRKMil: Runge-Kutta Milstein Method (Nonstiff)\n\nExplicit Runge-Kutta discretization of the Milstein method achieving strong order 1.0 convergence for diagonal and scalar noise.\n\nMethod Properties\n\nStrong Order: 1.0 (for diagonal/scalar noise)\nWeak Order: Depends on tableau\nTime stepping: Adaptive\nNoise types: Diagonal and scalar noise only\nSDE interpretation: Configurable (Itô or Stratonovich)\n\nParameters\n\ninterpretation: Choose AlgorithmInterpretation.Ito (default) or AlgorithmInterpretation.Stratonovich\n\nWhen to Use\n\nWhen higher accuracy than Euler methods is needed\nFor diagonal or scalar noise problems\nWhen strong order 1.0 convergence is required\nAlternative to SRI methods for simpler noise structures\n\nRestrictions\n\nOnly works with diagonal or scalar noise\nFor non-diagonal noise, use RKMilCommute or RKMilGeneral\nFor general noise, use SRI/SRA methods\n\nAlgorithm Description\n\nImplements the Milstein scheme using Runge-Kutta techniques:\n\ndu = f(u,t)dt + g(u,t)dW + 0.5*g(u,t)*g'(u,t)*(dW^2 - dt)\n\nwhere g'(u,t) is the derivative of g with respect to u.\n\nReferences\n\nKloeden, P.E., Platen, E., \"Numerical Solution of Stochastic Differential Equations\", Springer (1992)\nMilstein, G.N., \"Numerical Integration of Stochastic Differential Equations\"\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/basic_methods/#Split-Methods","page":"Basic Nonstiff Methods","title":"Split Methods","text":"","category":"section"},{"location":"nonstiff/basic_methods/#SplitEM-Split-Euler-Maruyama","page":"Basic Nonstiff Methods","title":"SplitEM - Split Euler-Maruyama","text":"","category":"section"},{"location":"nonstiff/basic_methods/#StochasticDiffEq.SplitEM","page":"Basic Nonstiff Methods","title":"StochasticDiffEq.SplitEM","text":"SplitEM()\n\nSplitEM: Split-Step Euler-Maruyama Method (Nonstiff)\n\nSplit-step version of the Euler-Maruyama method that separates the drift and diffusion terms for improved stability.\n\nMethod Properties\n\nStrong Order: 0.5 (in the Itô sense)\nWeak Order: 1.0\nTime stepping: Fixed time step\nNoise types: All forms (diagonal, non-diagonal, scalar, additive, and colored noise)\nSDE interpretation: Itô\n\nWhen to Use\n\nWhen standard EM has stability issues with large diffusion terms\nAlternative to EM with split=true\nFor problems where operator splitting is natural\nWhen drift and diffusion have different timescales\n\nAlgorithm Description\n\nApplies operator splitting to treat drift and diffusion separately:\n\nStep 1: u* = u_n + f(u_n,t_n)Δt     (drift step)\nStep 2: u_{n+1} = u* + g(u*,t_n)ΔW_n (diffusion step)\n\nReferences\n\nOperator splitting methods for SDEs\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/basic_methods/#When-to-Use-Basic-Methods","page":"Basic Nonstiff Methods","title":"When to Use Basic Methods","text":"","category":"section"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Use EM when:","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Computational efficiency is most important\nProblem is not stiff\nAny noise type (most flexible)\nSimple implementation needed","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Use EulerHeun when:","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Working in Stratonovich interpretation\nNeed slightly better accuracy than EM\nProblem has non-commutative noise","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Use LambaEM/LambaEulerHeun when:","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Want adaptive time stepping with basic methods\nNeed error control but not high accuracy\nGood balance of simplicity and adaptivity","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Use RKMil when:","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Higher accuracy than Euler methods\nProblem has diagonal or scalar noise\nStrong order 1.0 convergence required","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"These methods form the foundation of stochastic numerical analysis. While higher-order methods often provide better performance, the basic methods are essential for:","category":"page"},{"location":"nonstiff/basic_methods/","page":"Basic Nonstiff Methods","title":"Basic Nonstiff Methods","text":"Initial testing and prototyping\nProblems where simplicity is preferred\nEducational purposes\nFallback options when advanced methods fail","category":"page"},{"location":"#StochasticDiffEq.jl","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"StochasticDiffEq.jl is a component package in the DifferentialEquations ecosystem for solving stochastic differential equations (SDEs) and random ordinary differential equations (RODEs). It provides a comprehensive suite of high-performance numerical methods for stochastic problems.","category":"page"},{"location":"#Installation","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Installation","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"To install StochasticDiffEq.jl, use the Julia package manager:","category":"page"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"using Pkg\nPkg.add(\"StochasticDiffEq\")","category":"page"},{"location":"#Quick-Start","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Quick Start","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"Here's a simple example of solving an SDE:","category":"page"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"using StochasticDiffEq\n\n# Define the drift and diffusion functions\nfunction drift!(du, u, p, t)\n    du[1] = 1.01 * u[1]\nend\n\nfunction diffusion!(du, u, p, t)\n    du[1] = 0.87 * u[1]\nend\n\n# Initial condition and time span\nu0 = [0.5]\ntspan = (0.0, 1.0)\n\n# Define the SDE problem\nprob = SDEProblem(drift!, diffusion!, u0, tspan)\n\n# Solve using the default algorithm\nsol = solve(prob)","category":"page"},{"location":"#Solver-Categories","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Solver Categories","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"StochasticDiffEq.jl provides several categories of solvers optimized for different types of problems:","category":"page"},{"location":"#Nonstiff-Solvers","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Nonstiff Solvers","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"Basic Methods: Euler-Maruyama, Heun methods\nSRA/SRI Methods: High-order adaptive methods (SOSRI, SOSRA)\nHigh Weak Order: Methods optimized for weak convergence (DRI1)\nCommutative Noise: Specialized methods for commuting noise terms","category":"page"},{"location":"#Stiff-Solvers","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Stiff Solvers","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"Implicit Methods: Drift-implicit methods for stiff problems\nSplit-Step Methods: Methods handling stiffness in diffusion\nStabilized Methods: SROCK-type methods for parabolic PDEs","category":"page"},{"location":"#Jump-Diffusion","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Jump-Diffusion","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"Tau-Leaping: Methods for jump-diffusion processes","category":"page"},{"location":"#Recommended-Methods","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Recommended Methods","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"For most users, we recommend starting with these methods:","category":"page"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"General Purpose: SOSRI() - Excellent for diagonal/scalar Itô SDEs\nAdditive Noise: SOSRA() - Optimal for problems with additive noise\nStiff Problems: SKenCarp() - Best for stiff problems with additive noise\nCommutative Noise: RKMilCommute() - For multi-dimensional commutative noise\nHigh Efficiency: EM() - When computational speed is most important","category":"page"},{"location":"#Advanced-Features","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"Advanced Features","text":"","category":"section"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"Adaptive time stepping with sophisticated error control\nSupport for all noise types (diagonal, non-diagonal, additive, scalar)\nBoth Itô and Stratonovich interpretations\nIntegration with the broader DifferentialEquations.jl ecosystem\nGPU compatibility for high-performance computing\nExtensive callback and event handling capabilities","category":"page"},{"location":"","page":"StochasticDiffEq.jl: SDE solvers and utilities","title":"StochasticDiffEq.jl: SDE solvers and utilities","text":"See the individual solver pages for detailed information about each method's properties, when to use them, and their theoretical foundations.","category":"page"}]
}
